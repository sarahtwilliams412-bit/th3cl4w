<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>th3cl4w ‚Äî 3D Map Viewer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #111; color: #0f0; font-family: 'Courier New', monospace; overflow: hidden; }
#container { width: 100vw; height: 100vh; position: relative; }
canvas { display: block; }

#hud {
    position: absolute; top: 10px; left: 10px; z-index: 10;
    background: rgba(0,0,0,0.85); padding: 14px; border: 1px solid #0f0;
    border-radius: 4px; font-size: 13px; max-width: 320px;
}
#hud h2 { margin-bottom: 8px; font-size: 15px; }
#hud .status { color: #0a0; margin-bottom: 8px; }
#hud button {
    background: #0f0; color: #000; border: none; padding: 5px 12px;
    cursor: pointer; font-family: inherit; font-weight: bold;
    margin: 2px 2px 2px 0; border-radius: 2px; font-size: 11px;
}
#hud button:hover { background: #0c0; }
#hud button.danger { background: #f44; color: #fff; }
#hud button.active { background: #ff0; color: #000; }
#hud button:disabled { opacity: 0.4; cursor: not-allowed; }
.section { margin-top: 8px; padding-top: 6px; border-top: 1px solid #030; }
.section-title { font-size: 11px; color: #080; margin-bottom: 4px; }

#layers { display: flex; flex-wrap: wrap; gap: 4px; }
#layers label { font-size: 11px; cursor: pointer; }
#layers input { margin-right: 2px; }

#cameras { margin-top: 6px; }
#cameras button { font-size: 10px; padding: 3px 8px; }

#stats {
    position: absolute; bottom: 10px; left: 10px; z-index: 10;
    background: rgba(0,0,0,0.8); padding: 8px 12px; border: 1px solid #030;
    border-radius: 4px; font-size: 11px; color: #080;
}

#scan-panel {
    position: absolute; top: 10px; right: 10px; z-index: 10;
    background: rgba(0,0,0,0.85); padding: 12px; border: 1px solid #0f0;
    border-radius: 4px; font-size: 12px; max-width: 250px;
}
#scan-panel h3 { margin-bottom: 6px; font-size: 13px; }
.scan-item { padding: 3px 0; border-bottom: 1px solid #030; cursor: pointer; font-size: 11px; }
.scan-item:hover { color: #fff; }

.slider-row { display: flex; align-items: center; gap: 6px; margin: 4px 0; font-size: 11px; }
.slider-row input[type=range] { flex: 1; }
</style>
</head>
<body>
<div id="container">
    <div id="hud">
        <h2>üó∫Ô∏è 3D Map</h2>
        <div id="status" class="status">Connecting...</div>

        <div class="section">
            <div class="section-title">LAYERS</div>
            <div id="layers">
                <label><input type="checkbox" id="layer-arm" checked onchange="toggleLayer('arm')"> Arm</label>
                <label><input type="checkbox" id="layer-env" checked onchange="toggleLayer('env')"> Points</label>
                <label><input type="checkbox" id="layer-objects" checked onchange="toggleLayer('objects')"> Objects</label>
                <label><input type="checkbox" id="layer-collision" onchange="toggleLayer('collision')"> Collision</label>
                <label><input type="checkbox" id="layer-reach" checked onchange="toggleLayer('reach')"> Reach</label>
                <label><input type="checkbox" id="layer-waypoints" checked onchange="toggleLayer('waypoints')"> Waypoints</label>
            </div>
        </div>

        <div class="section">
            <div class="section-title">CONTROLS</div>
            <div class="slider-row">
                <span>Pt Size</span>
                <input type="range" id="pt-size" min="1" max="10" value="3" oninput="setPointSize(this.value)">
                <span id="pt-size-val">3</span>
            </div>
            <div class="slider-row">
                <span>Update Hz</span>
                <input type="range" id="update-hz" min="1" max="30" value="15" oninput="setUpdateRate(this.value)">
                <span id="hz-val">15</span>
            </div>
        </div>

        <div class="section" id="cameras">
            <div class="section-title">CAMERA</div>
            <button onclick="setCam('top')">Top</button>
            <button onclick="setCam('front')">Front</button>
            <button onclick="setCam('side')">Side</button>
            <button onclick="setCam('iso')">Iso</button>
        </div>

        <div class="section">
            <button onclick="clearEnv()">Clear Env</button>
            <button onclick="requestFull()">Refresh</button>
            <a href="/static/scan3d.html" style="color:#0f0;margin-left:8px;font-size:11px;">Scan Viewer</a>
            <a href="/" style="color:#0f0;margin-left:8px;font-size:11px;">API</a>
        </div>
    </div>

    <div id="scan-panel">
        <h3>üîç Scan</h3>
        <div id="scan-status">Ready</div>
        <button id="btn-scan" onclick="startScan()">Start Scan</button>
        <button id="btn-stop" class="danger" onclick="stopScan()" disabled>Stop</button>
        <button onclick="loadLatestPLY()">Load PLY</button>
        <button onclick="listScans()">List</button>
        <div id="scans" style="margin-top:6px;max-height:200px;overflow-y:auto;"></div>
    </div>

    <div id="stats">
        FPS: <span id="fps">0</span> |
        Points: <span id="point-count">0</span> |
        Objects: <span id="obj-count">0</span> |
        Frame: <span id="frame-num">0</span> |
        WS: <span id="ws-status">disconnected</span>
    </div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "/static/lib/three-0.162.0/three.module.js",
        "three/addons/": "/static/lib/three-0.162.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

// --- Scene Setup ---
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
camera.position.set(0.5, 0.5, 0.5);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.1;

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
dirLight.position.set(1, 2, 1);
scene.add(dirLight);

// Grid
const grid = new THREE.GridHelper(2, 40, 0x003300, 0x001800);
scene.add(grid);
const axes = new THREE.AxesHelper(0.15);
scene.add(axes);

// --- Layer Groups ---
const armGroup = new THREE.Group(); armGroup.name = 'arm'; scene.add(armGroup);
const envGroup = new THREE.Group(); envGroup.name = 'environment'; scene.add(envGroup);
const objGroup = new THREE.Group(); objGroup.name = 'objects'; scene.add(objGroup);
const collisionGroup = new THREE.Group(); collisionGroup.name = 'collision'; collisionGroup.visible = false; scene.add(collisionGroup);
const reachGroup = new THREE.Group(); reachGroup.name = 'reach_envelope'; scene.add(reachGroup);
const waypointGroup = new THREE.Group(); waypointGroup.name = 'waypoints'; scene.add(waypointGroup);

// --- Arm rendering ---
const jointMeshes = [];
const linkMeshes = [];
const JOINT_COLOR = 0x00ff88;
const LINK_COLOR = 0x00aa66;

function updateArm(armData) {
    if (!armData || !armData.joints || armData.joints.length === 0) return;

    const joints = armData.joints;
    const links = armData.links || [];

    // Ensure we have enough joint meshes
    while (jointMeshes.length < joints.length) {
        const m = new THREE.Mesh(
            new THREE.SphereGeometry(0.02, 12, 12),
            new THREE.MeshPhongMaterial({ color: JOINT_COLOR, emissive: 0x004422 })
        );
        armGroup.add(m);
        jointMeshes.push(m);
    }
    // Update positions
    for (let i = 0; i < joints.length; i++) {
        jointMeshes[i].position.set(joints[i][0], joints[i][2], -joints[i][1]); // Y-up swap
        jointMeshes[i].visible = true;
        jointMeshes[i].scale.setScalar(i === 0 ? 1.5 : 1.0);
    }
    for (let i = joints.length; i < jointMeshes.length; i++) {
        jointMeshes[i].visible = false;
    }

    // Links as cylinders
    while (linkMeshes.length < links.length) {
        const m = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015, 0.015, 1, 8),
            new THREE.MeshPhongMaterial({ color: LINK_COLOR, emissive: 0x002211 })
        );
        armGroup.add(m);
        linkMeshes.push(m);
    }
    for (let i = 0; i < links.length; i++) {
        const s = new THREE.Vector3(links[i].start[0], links[i].start[2], -links[i].start[1]);
        const e = new THREE.Vector3(links[i].end[0], links[i].end[2], -links[i].end[1]);
        const mid = new THREE.Vector3().addVectors(s, e).multiplyScalar(0.5);
        const dir = new THREE.Vector3().subVectors(e, s);
        const len = dir.length();

        linkMeshes[i].position.copy(mid);
        linkMeshes[i].scale.set(links[i].radius / 0.015, len, links[i].radius / 0.015);
        linkMeshes[i].quaternion.setFromUnitVectors(
            new THREE.Vector3(0, 1, 0), dir.normalize()
        );
        linkMeshes[i].visible = true;
    }
    for (let i = links.length; i < linkMeshes.length; i++) {
        linkMeshes[i].visible = false;
    }
}

// --- Point cloud ---
let envPoints = null;
const MAX_POINTS = 200000;
let pointSize = 3;

function updateEnv(envData) {
    if (!envData) return;

    const pts = envData.new_points;
    if (!pts || pts.length === 0) return;

    if (envData.update_mode === 'full' || !envPoints) {
        // Replace entire cloud
        if (envPoints) envGroup.remove(envPoints);

        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(MAX_POINTS * 3);
        const colors = new Float32Array(MAX_POINTS * 3);

        for (let i = 0; i < Math.min(pts.length, MAX_POINTS); i++) {
            // Y-up swap: x, z, -y
            positions[i*3] = pts[i][0];
            positions[i*3+1] = pts[i][2];
            positions[i*3+2] = -pts[i][1];
            colors[i*3] = (pts[i][3] || 128) / 255;
            colors[i*3+1] = (pts[i][4] || 128) / 255;
            colors[i*3+2] = (pts[i][5] || 128) / 255;
        }

        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geo.setDrawRange(0, Math.min(pts.length, MAX_POINTS));

        const mat = new THREE.PointsMaterial({
            size: pointSize * 0.001,
            vertexColors: true,
            sizeAttenuation: true,
        });
        envPoints = new THREE.Points(geo, mat);
        envGroup.add(envPoints);
    } else {
        // Delta: append points
        const geo = envPoints.geometry;
        const posAttr = geo.attributes.position;
        const colAttr = geo.attributes.color;
        const currentCount = geo.drawRange.count;

        for (let i = 0; i < pts.length && currentCount + i < MAX_POINTS; i++) {
            const idx = currentCount + i;
            posAttr.array[idx*3] = pts[i][0];
            posAttr.array[idx*3+1] = pts[i][2];
            posAttr.array[idx*3+2] = -pts[i][1];
            colAttr.array[idx*3] = (pts[i][3] || 128) / 255;
            colAttr.array[idx*3+1] = (pts[i][4] || 128) / 255;
            colAttr.array[idx*3+2] = (pts[i][5] || 128) / 255;
        }
        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;
        geo.setDrawRange(0, Math.min(currentCount + pts.length, MAX_POINTS));
    }

    // Update stats
    const stats = envData.stats || {};
    document.getElementById('point-count').textContent = (stats.total_points || 0).toLocaleString();
}

// --- Objects ---
const objectMeshes = {};

function updateObjects(objects) {
    if (!objects) return;

    const seen = new Set();
    for (const obj of objects) {
        seen.add(obj.id);
        let mesh = objectMeshes[obj.id];
        if (!mesh) {
            const w = (obj.bbox_mm[0] || 50) / 1000;
            const d = (obj.bbox_mm[1] || 50) / 1000;
            const h = (obj.bbox_mm[2] || 50) / 1000;
            const geo = new THREE.BoxGeometry(w, h, d);
            const edges = new THREE.EdgesGeometry(geo);
            const color = obj.reachable ? 0x00ff00 : 0xff4444;
            mesh = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color }));
            objGroup.add(mesh);
            objectMeshes[obj.id] = mesh;

            // Label sprite
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = obj.reachable ? '#0f0' : '#f44';
            ctx.font = 'bold 24px monospace';
            ctx.fillText(obj.label, 4, 40);
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(0.1, 0.025, 1);
            sprite.position.y = h / 2 + 0.02;
            mesh.add(sprite);
        }
        // Y-up swap
        const px = obj.position_mm[0] / 1000;
        const py = obj.position_mm[2] / 1000;
        const pz = -obj.position_mm[1] / 1000;
        mesh.position.set(px, py, pz);
    }
    // Remove stale objects
    for (const id of Object.keys(objectMeshes)) {
        if (!seen.has(id)) {
            objGroup.remove(objectMeshes[id]);
            delete objectMeshes[id];
        }
    }
    document.getElementById('obj-count').textContent = objects.length;
}

// --- Collision voxels ---
let collisionMesh = null;

function updateCollision(voxels) {
    if (!voxels || voxels.length === 0) return;
    if (collisionMesh) collisionGroup.remove(collisionMesh);

    const voxelSize = 0.01;
    const geo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.15 });
    const instanced = new THREE.InstancedMesh(geo, mat, Math.min(voxels.length, 10000));

    const dummy = new THREE.Object3D();
    for (let i = 0; i < Math.min(voxels.length, 10000); i++) {
        dummy.position.set(voxels[i][0], voxels[i][2], -voxels[i][1]);
        dummy.updateMatrix();
        instanced.setMatrixAt(i, dummy.matrix);
    }
    collisionMesh = instanced;
    collisionGroup.add(instanced);
}

// --- Reach envelope ---
async function loadReachEnvelope() {
    try {
        const resp = await fetch('/api/map/reach-envelope');
        const data = await resp.json();
        if (!data.vertices || data.vertices.length === 0) return;

        const geo = new THREE.BufferGeometry();
        const verts = new Float32Array(data.vertices.length * 3);
        for (let i = 0; i < data.vertices.length; i++) {
            verts[i*3] = data.vertices[i][0];
            verts[i*3+1] = data.vertices[i][2];
            verts[i*3+2] = -data.vertices[i][1];
        }
        geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));

        if (data.faces && data.faces.length > 0) {
            const indices = [];
            for (const f of data.faces) indices.push(f[0], f[1], f[2]);
            geo.setIndex(indices);
        }

        const mat = new THREE.MeshBasicMaterial({
            color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.1,
        });
        const mesh = new THREE.Mesh(geo, mat);
        reachGroup.add(mesh);
    } catch (e) {
        console.warn('Could not load reach envelope:', e);
    }
}

// --- WebSocket ---
let ws = null;
let wsRetry = 1000;

function connectWS() {
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const url = `${proto}//${location.host}/ws/map`;
    ws = new WebSocket(url);

    ws.onopen = () => {
        document.getElementById('ws-status').textContent = 'connected';
        document.getElementById('status').textContent = 'Connected ‚úì';
        wsRetry = 1000;
    };

    ws.onmessage = (ev) => {
        try {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'scene_update') {
                const d = msg.data;
                if (d.arm) updateArm(d.arm);
                if (d.env) updateEnv(d.env);
                if (d.objects) updateObjects(d.objects);
                if (d.collision_voxels) updateCollision(d.collision_voxels);
                if (d.frame) document.getElementById('frame-num').textContent = d.frame;
            }
        } catch (e) { console.error('WS parse error:', e); }
    };

    ws.onclose = () => {
        document.getElementById('ws-status').textContent = 'disconnected';
        document.getElementById('status').textContent = 'Reconnecting...';
        setTimeout(connectWS, wsRetry);
        wsRetry = Math.min(wsRetry * 1.5, 10000);
    };

    ws.onerror = () => ws.close();
}

// --- Controls ---
window.toggleLayer = function(name) {
    const groups = { arm: armGroup, env: envGroup, objects: objGroup, collision: collisionGroup, reach: reachGroup, waypoints: waypointGroup };
    const g = groups[name];
    if (g) g.visible = document.getElementById(`layer-${name}`).checked;
};

window.setPointSize = function(v) {
    pointSize = parseInt(v);
    document.getElementById('pt-size-val').textContent = v;
    if (envPoints) envPoints.material.size = pointSize * 0.001;
};

window.setUpdateRate = function(v) {
    document.getElementById('hz-val').textContent = v;
    if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: 'set_update_rate', hz: parseInt(v) }));
    }
};

window.setCam = function(preset) {
    const d = 0.6;
    const presets = {
        top:   [0, d*1.5, 0],
        front: [0, d*0.3, d],
        side:  [d, d*0.3, 0],
        iso:   [d*0.7, d*0.7, d*0.7],
    };
    const p = presets[preset] || presets.iso;
    camera.position.set(p[0], p[1], p[2]);
    controls.target.set(0, 0.15, 0);
    controls.update();
};

window.clearEnv = async function() {
    await fetch('/api/map/env/clear', { method: 'POST' });
    if (envPoints) { envGroup.remove(envPoints); envPoints = null; }
    document.getElementById('point-count').textContent = '0';
};

window.requestFull = function() {
    if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: 'request_full_scene' }));
    }
};

// --- Scan controls ---
let scanPoll = null;

window.startScan = async function() {
    const resp = await fetch('/api/map/scan/start', { method: 'POST' });
    const data = await resp.json();
    document.getElementById('scan-status').textContent = data.ok ? `Scanning (${data.total_poses} poses)` : `Error: ${data.error}`;
    if (data.ok) {
        document.getElementById('btn-scan').disabled = true;
        document.getElementById('btn-stop').disabled = false;
        scanPoll = setInterval(pollScan, 1000);
    }
};

window.stopScan = async function() {
    await fetch('/api/map/scan/stop', { method: 'POST' });
    document.getElementById('btn-scan').disabled = false;
    document.getElementById('btn-stop').disabled = true;
    if (scanPoll) clearInterval(scanPoll);
};

async function pollScan() {
    try {
        const resp = await fetch('/api/map/scan/status');
        const s = await resp.json();
        document.getElementById('scan-status').textContent =
            `${s.phase} ‚Äî ${s.current_pose}/${s.total_poses} (${s.points_total} pts)`;
        if (!s.running && s.phase !== 'idle') {
            document.getElementById('btn-scan').disabled = false;
            document.getElementById('btn-stop').disabled = true;
            if (scanPoll) clearInterval(scanPoll);
        }
    } catch (e) { console.error(e); }
}

window.loadLatestPLY = function() {
    const loader = new PLYLoader();
    loader.load('/api/map/scan/result', (geo) => {
        if (envPoints) envGroup.remove(envPoints);
        geo.computeBoundingBox();
        const center = new THREE.Vector3();
        geo.boundingBox.getCenter(center);
        geo.translate(-center.x, -center.y, -center.z);

        const mat = new THREE.PointsMaterial({
            size: pointSize * 0.001,
            vertexColors: geo.hasAttribute('color'),
            color: geo.hasAttribute('color') ? undefined : 0x00ff00,
        });
        envPoints = new THREE.Points(geo, mat);
        envGroup.add(envPoints);
        document.getElementById('point-count').textContent = geo.attributes.position.count.toLocaleString();
    });
};

window.listScans = async function() {
    try {
        const resp = await fetch('/api/map/scan/list');
        const data = await resp.json();
        const el = document.getElementById('scans');
        if (!data.scans || data.scans.length === 0) {
            el.innerHTML = '<div style="color:#555">No scans</div>';
            return;
        }
        el.innerHTML = data.scans.map(s =>
            `<div class="scan-item" onclick="loadScanPLY('${s.scan_id}')">${s.scan_id} ‚Äî ${(s.total_points||0).toLocaleString()} pts</div>`
        ).join('');
    } catch(e) { console.error(e); }
};

window.loadScanPLY = function(id) {
    const loader = new PLYLoader();
    loader.load(`/api/map/scan/result?scan_id=${id}`, (geo) => {
        if (envPoints) envGroup.remove(envPoints);
        const mat = new THREE.PointsMaterial({ size: pointSize * 0.001, vertexColors: geo.hasAttribute('color'), color: 0x00ff00 });
        envPoints = new THREE.Points(geo, mat);
        envGroup.add(envPoints);
    });
};

// --- FPS counter ---
let frameCount = 0, lastFpsTime = performance.now();

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
    frameCount++;
    const now = performance.now();
    if (now - lastFpsTime > 1000) {
        document.getElementById('fps').textContent = frameCount;
        frameCount = 0;
        lastFpsTime = now;
    }
}

// --- Init ---
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
connectWS();
loadReachEnvelope();
window.listScans();
</script>
</body>
</html>
