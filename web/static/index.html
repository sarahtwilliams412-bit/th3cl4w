<!-- th3cl4w V1 Control Panel ‚Äî Stable Base -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>th3cl4w ‚Äî D1 Arm Control</title>
<style>
/* === Variables & Reset === */
:root {
  --bg: #1a1a2e;
  --card: #16213e;
  --card-border: #1a2744;
  --primary: #0f3460;
  --danger: #e94560;
  --success: #53d769;
  --warning: #f0ad4e;
  --info: #4a90d9;
  --text: #e0e0e0;
  --text-dim: #8892a4;
  --mono: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
  --sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: var(--bg); color: var(--text); font-family: var(--sans); height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

/* === Top Bar === */
.topbar { display: flex; align-items: center; gap: 12px; padding: 8px 16px; background: var(--card); border-bottom: 1px solid var(--card-border); flex-shrink: 0; }
.logo { font-family: var(--mono); font-size: 18px; font-weight: 700; letter-spacing: 2px; color: var(--danger); }
.conn-dot { width: 10px; height: 10px; border-radius: 50%; background: #666; flex-shrink: 0; }
.conn-dot.on { background: var(--success); box-shadow: 0 0 8px var(--success); }
.conn-dot.off { background: var(--danger); box-shadow: 0 0 8px var(--danger); }
.badge { font-size: 10px; font-family: var(--mono); padding: 2px 8px; border-radius: 3px; background: #1a2744; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; }
.badge.active { background: #0a3d20; color: var(--success); }
.badge.error { background: #3d0a0a; color: var(--danger); }
.conn-quality { font-family: var(--mono); font-size: 10px; color: var(--text-dim); }
.topbar-spacer { flex: 1; }

/* === Layout === */
.main { display: flex; flex: 1; overflow: hidden; }
.panel-left { flex: 1; min-width: 300px; display: flex; flex-direction: column; border-right: 1px solid var(--card-border); }
.panel-right { width: 400px; flex-shrink: 0; display: flex; flex-direction: column; overflow-y: auto; }

/* === Visualization === */
.viz-container { flex: 1; display: flex; align-items: center; justify-content: center; padding: 8px; }
.viz-container canvas { max-width: 100%; max-height: 100%; }

/* === Controls === */
.controls { padding: 12px; display: flex; flex-direction: column; gap: 10px; }
.section-title { font-family: var(--mono); font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 2px; }

/* === Joint Sliders === */
.joint-row { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
.joint-label { font-family: var(--mono); font-size: 11px; width: 22px; color: var(--text-dim); text-align: right; }
.joint-slider { flex: 1; -webkit-appearance: none; appearance: none; height: 5px; background: #1a2744; border-radius: 3px; outline: none; }
.joint-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--primary); cursor: pointer; border: 2px solid #4a90d9; }
.joint-slider::-webkit-slider-thumb:hover { background: #4a90d9; }
.joint-slider::-moz-range-thumb { width: 12px; height: 12px; border-radius: 50%; background: var(--primary); cursor: pointer; border: 2px solid #4a90d9; }
.joint-value { font-family: var(--mono); font-size: 11px; width: 58px; text-align: right; color: var(--text); }
.joint-range { font-family: var(--mono); font-size: 9px; color: #555; width: 40px; text-align: center; }

/* === Buttons === */
.btn-row { display: flex; gap: 6px; flex-wrap: wrap; }
.btn { font-family: var(--mono); font-size: 11px; padding: 6px 12px; border: 1px solid var(--card-border); border-radius: 4px; cursor: pointer; background: var(--card); color: var(--text); transition: all 0.15s; text-transform: uppercase; letter-spacing: 1px; }
.btn:hover:not(:disabled) { background: var(--primary); border-color: #4a90d9; }
.btn:active:not(:disabled) { transform: scale(0.97); }
.btn:disabled { opacity: 0.35; cursor: not-allowed; }
.btn.on { background: #0a3d20; border-color: var(--success); color: var(--success); }
.btn.danger-active { background: #3d1a1a; border-color: var(--danger); color: var(--danger); }

/* === Emergency Stop === */
.estop { width: 100%; padding: 14px; font-size: 15px; font-weight: 700; background: var(--danger); color: #fff; border: 2px solid #ff6b81; border-radius: 6px; cursor: pointer; letter-spacing: 3px; text-transform: uppercase; font-family: var(--mono); transition: all 0.15s; }
.estop:hover { background: #ff2244; box-shadow: 0 0 20px rgba(233,69,96,0.5); }
.estop:active { transform: scale(0.98); }
.estop.flash { animation: estop-flash 0.8s infinite; }
@keyframes estop-flash { 0%,100% { box-shadow: 0 0 5px rgba(233,69,96,0.3); } 50% { box-shadow: 0 0 25px rgba(233,69,96,0.8); border-color: #fff; } }

/* === Raw Command Input === */
.raw-cmd { display: flex; gap: 6px; margin-top: 4px; }
.raw-cmd input { flex: 1; font-family: var(--mono); font-size: 11px; padding: 6px 8px; background: #0d1525; border: 1px solid var(--card-border); border-radius: 4px; color: var(--text); outline: none; }
.raw-cmd input:focus { border-color: var(--info); }

/* === Action Log === */
.log-panel { height: 150px; flex-shrink: 0; border-top: 1px solid var(--card-border); display: flex; flex-direction: column; }
.log-title { font-family: var(--mono); font-size: 10px; color: var(--text-dim); padding: 6px 12px 2px; text-transform: uppercase; letter-spacing: 2px; flex-shrink: 0; }
.log-scroll { flex: 1; overflow-y: auto; padding: 0 12px 6px; font-family: var(--mono); font-size: 10px; line-height: 1.5; }
.log-entry { white-space: nowrap; }
.log-entry .ts { color: #444; margin-right: 6px; }
.log-entry .act { margin-right: 6px; font-weight: 600; }
.log-entry.info .act { color: var(--info); }
.log-entry.error .act { color: var(--danger); }
.log-entry.warning .act { color: var(--warning); }
.log-entry.info .detail { color: var(--text-dim); }
.log-entry.error .detail { color: #d9534f; }
.log-entry.warning .detail { color: #c09853; }

/* === Camera Panel === */
.camera-panel { border-top: 1px solid var(--card-border); flex-shrink: 0; }
.camera-header { display: flex; align-items: center; justify-content: space-between; padding: 6px 12px; }
.cam-toggle { font-size: 10px !important; padding: 3px 8px !important; }
.camera-feeds { display: flex; gap: 8px; padding: 0 12px 8px; }
.camera-feeds.hidden { display: none; }
.cam-feed { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 4px; }
.cam-label { font-family: var(--mono); font-size: 10px; color: var(--text-dim); display: flex; align-items: center; gap: 6px; }
.cam-live { color: var(--danger); font-size: 9px; animation: cam-blink 2s infinite; }
@keyframes cam-blink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
.cam-img { width: 100%; aspect-ratio: 4/3; object-fit: contain; background: #0d1525; border: 1px solid var(--card-border); border-radius: 4px; }
.cam-snap { font-size: 9px !important; padding: 2px 6px !important; align-self: flex-start; }

/* === Scrollbar === */
::-webkit-scrollbar { width: 5px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: #2a3a5c; border-radius: 3px; }

/* === Debug Panel === */
.debug-panel { background: #111827; border-top: 2px solid #4a90d9; font-family: var(--mono); font-size: 11px; padding: 8px 12px; overflow-y: auto; max-height: 340px; }
.debug-section { margin-bottom: 10px; }
.debug-title { font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 6px; }
.debug-pipeline { display: flex; align-items: center; gap: 4px; flex-wrap: wrap; }
.pipe-stage { display: flex; flex-direction: column; align-items: center; gap: 2px; padding: 4px 8px; border: 1px solid #333; border-radius: 4px; min-width: 54px; background: #0d1525; }
.pipe-stage.active { border-color: var(--success); }
.pipe-stage.active .pipe-dot { background: var(--success); box-shadow: 0 0 6px var(--success); }
.pipe-stage.error { border-color: var(--danger); }
.pipe-stage.error .pipe-dot { background: var(--danger); box-shadow: 0 0 6px var(--danger); }
.pipe-dot { width: 6px; height: 6px; border-radius: 50%; background: #444; }
.pipe-label { font-size: 9px; color: var(--text-dim); }
.pipe-latency { font-size: 8px; color: #555; }
.pipe-arrow { color: #444; font-size: 14px; }
.debug-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
.stat-group { background: #0d1525; border: 1px solid #333; border-radius: 4px; padding: 6px 8px; }
.stat-header { font-size: 9px; color: var(--info); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
.stat-row { display: flex; justify-content: space-between; gap: 6px; padding: 1px 0; }
.stat-row span:first-child { color: var(--text-dim); font-size: 9px; }
.stat-row span:last-child { color: var(--text); font-size: 10px; }
.debug-events { background: #0d1525; border: 1px solid #333; border-radius: 4px; padding: 4px 8px; max-height: 140px; overflow-y: auto; font-size: 10px; line-height: 1.6; }
.debug-evt { white-space: nowrap; }
.debug-evt .de-ts { color: #555; margin-right: 4px; }
.debug-evt .de-type { font-weight: 600; margin-right: 4px; }
.debug-evt .de-cid { color: #666; margin-right: 4px; }
.debug-evt .de-pay { color: var(--text-dim); }
.de-CMD_SENT { color: #4a90d9; }
.de-DDS_PUBLISH { color: #9b59b6; }
.de-DDS_RECEIVE { color: #53d769; }
.de-CMD_ACK { color: #7fff00; }
.de-CMD_EXEC { color: #2e8b57; }
.de-STATE_UPDATE { color: #f0ad4e; }
.de-WS_SEND { color: #87ceeb; }
.de-ERROR { color: #e94560; }
.de-CAM_FRAME { color: #888; }

/* === Tabs === */
.tab-bar { display: flex; gap: 0; margin-left: 16px; }
.tab-btn { font-family: var(--mono); font-size: 11px; padding: 6px 14px; border: 1px solid transparent; border-bottom: none; border-radius: 4px 4px 0 0; cursor: pointer; background: transparent; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; transition: all 0.15s; position: relative; top: 1px; }
.tab-btn:hover { color: var(--text); background: rgba(255,255,255,0.03); }
.tab-btn.active { background: var(--bg); color: var(--text); border-color: var(--card-border); }
.tab-content { display: none; flex: 1; flex-direction: column; overflow: hidden; }
.tab-content.active { display: flex; }
.beta-pill { font-size: 8px; padding: 1px 5px; border-radius: 8px; background: rgba(240,173,78,0.2); color: var(--warning); margin-left: 6px; vertical-align: middle; font-weight: 700; letter-spacing: 0.5px; }

/* === ASCII Tab === */
.ascii-tab-wrap { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
.ascii-controls-bar { display: flex; align-items: center; gap: 12px; padding: 6px 12px; background: var(--card); border-bottom: 1px solid var(--card-border); flex-wrap: wrap; flex-shrink: 0; }
.ascii-controls-bar label { font-family: var(--mono); font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; }
.ascii-controls-bar select, .ascii-controls-bar input[type="number"] { font-family: var(--mono); font-size: 11px; padding: 3px 6px; background: #0d1525; border: 1px solid var(--card-border); border-radius: 3px; color: var(--text); }
.ascii-controls-bar input[type="number"] { width: 50px; }
.ascii-toggle { font-family: var(--mono); font-size: 10px; padding: 4px 10px; border: 1px solid var(--card-border); border-radius: 3px; cursor: pointer; background: var(--card); color: var(--text-dim); transition: all 0.15s; }
.ascii-toggle:hover { background: var(--primary); }
.ascii-toggle.on { background: #0a3d20; border-color: var(--success); color: var(--success); }
.ascii-status-bar { display: flex; align-items: center; gap: 12px; padding: 4px 12px; background: #0d1117; border-bottom: 1px solid var(--card-border); font-family: var(--mono); font-size: 10px; color: var(--text-dim); flex-shrink: 0; }
.ascii-status-dot { width: 7px; height: 7px; border-radius: 50%; background: #666; }
.ascii-status-dot.on { background: var(--success); box-shadow: 0 0 6px var(--success); }
.ascii-status-dot.err { background: var(--danger); box-shadow: 0 0 6px var(--danger); }
.ascii-viewport { flex: 1; overflow: hidden; display: flex; align-items: center; justify-content: center; padding: 8px; gap: 12px; }
.ascii-pane { flex: 1; display: flex; flex-direction: column; align-items: center; overflow: hidden; min-width: 0; }
.ascii-pane-label { font-family: var(--mono); font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 4px; flex-shrink: 0; }
.ascii-pane pre { white-space: pre; line-height: 1.1; letter-spacing: 0.5px; color: #88cc88; text-align: center; user-select: text; font-family: var(--mono); }
.ascii-divider { width: 1px; background: var(--card-border); flex-shrink: 0; align-self: stretch; }
#asciiOutput { white-space: pre; line-height: 1.1; letter-spacing: 0.5px; color: #88cc88; text-align: center; user-select: text; font-family: var(--mono); }
#asciiOutput.color-mode { color: unset; }

/* === Responsive === */
@media (max-width: 800px) {
  .main { flex-direction: column; }
  .panel-left { min-height: 220px; border-right: none; border-bottom: 1px solid var(--card-border); }
  .panel-right { width: 100%; flex: 1; }
  .debug-stats { grid-template-columns: repeat(2, 1fr); }
}
/* === Collision Alert === */
.collision-alert { position: fixed; bottom: 12px; right: 12px; z-index: 9999; background: rgba(139,0,0,0.92); color: #fff; padding: 10px 14px; box-shadow: 0 2px 12px rgba(233,69,96,0.4); border-radius: 8px; border-left: 3px solid #e74c3c; animation: collisionFlash 0.3s ease-in-out; display: none; max-width: 340px; font-size: 12px; backdrop-filter: blur(8px); }
.collision-alert.visible { display: block; }
.collision-alert h3 { margin: 0 0 4px; font-family: var(--mono); font-size: 12px; }
.collision-alert p { margin: 2px 0; font-size: 11px; line-height: 1.3; }
.collision-alert .collision-images { display: flex; gap: 4px; margin: 6px 0; }
.collision-alert .collision-images img { width: 80px; height: 60px; object-fit: cover; border: 1px solid rgba(255,255,255,0.3); border-radius: 3px; }
.collision-alert .dismiss-btn { background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4); color: #fff; padding: 2px 12px; border-radius: 3px; cursor: pointer; font-family: var(--mono); font-size: 11px; margin-top: 4px; }
.collision-alert .dismiss-btn:hover { background: rgba(255,255,255,0.3); }
@keyframes collisionFlash { 0% { opacity: 0; transform: translateY(-20px); } 100% { opacity: 1; transform: translateY(0); } }
</style>
</head>
<body>

<div id="collisionAlert" class="collision-alert">
  <h3>‚ö† COLLISION DETECTED</h3>
  <p id="collisionInfo"></p>
  <p id="collisionAnalysis" style="font-style:italic; opacity:0.9;"></p>
  <div id="collisionImages" class="collision-images"></div>
  <button class="dismiss-btn" onclick="dismissCollision()">Dismiss</button>
</div>

<div class="topbar">
  <div class="logo">th3cl4w</div>
  <div class="conn-dot" id="connDot"></div>
  <span id="connLabel" style="font-size:11px;font-family:var(--mono);color:var(--text-dim)">DISCONNECTED</span>
  <span class="conn-quality" id="connQuality"></span>
  <div class="tab-bar">
    <button class="tab-btn active" data-tab="control">CONTROL</button>
    <button class="tab-btn" data-tab="ascii">ASCII VIDEO <span class="beta-pill">BETA</span></button>
  </div>
  <button class="btn" id="btnDebug" style="font-size:10px;padding:3px 8px">üîß DEBUG</button>
  <button class="btn" id="btnCalibrateViz" style="font-size:10px;padding:3px 8px" title="Calibrate arm visualization using camera">üìê CALIBRATE VIZ</button>
  <a href="/telemetry" class="btn" style="font-size:10px;padding:3px 8px;text-decoration:none">üìä TELEMETRY</a>
  <div class="topbar-spacer"></div>
  <div class="badge" id="badgePower">PWR OFF</div>
  <div class="badge" id="badgeEnabled">DISABLED</div>
  <div class="badge" id="badgeError">NO ERR</div>
</div>

<div class="tab-content active" id="tabControl">
<div class="main">
  <div class="panel-left">
    <div class="viz-container">
      <canvas id="armCanvas" width="600" height="500"></canvas>
    </div>
    <div class="camera-panel" id="cameraPanel">
      <div class="camera-header">
        <span class="section-title" style="margin:0">Cameras</span>
        <button class="btn cam-toggle" id="btnCamToggle" title="Toggle cameras">üëÅ HIDE</button>
      </div>
      <div class="camera-feeds" id="cameraFeeds">
        <div class="cam-feed">
          <div class="cam-label"><span class="cam-live">‚óè LIVE</span> Camera 1 (Left)</div>
          <img class="cam-img" id="camImg0" src="http://localhost:8081/cam/0" alt="Camera 1">
          <button class="btn cam-snap" onclick="window.open('http://localhost:8081/snap/0','_blank')">üì∑ Snap</button>
        </div>
        <div class="cam-feed">
          <div class="cam-label"><span class="cam-live">‚óè LIVE</span> Camera 2 (Right)</div>
          <img class="cam-img" id="camImg1" src="http://localhost:8081/cam/1" alt="Camera 2">
          <button class="btn cam-snap" onclick="window.open('http://localhost:8081/snap/1','_blank')">üì∑ Snap</button>
        </div>
      </div>
    </div>
  </div>

  <div class="panel-right">
    <div class="controls">
      <div class="section-title">Joint Control (6 DOF)</div>
      <div id="jointSliders"></div>

      <div style="margin-top:4px">
        <div class="section-title">Gripper</div>
        <div class="joint-row">
          <span class="joint-label">G</span>
          <input type="range" class="joint-slider" id="gripperSlider" min="0" max="65" step="0.5" value="0">
          <span class="joint-value" id="gripperValue">0.0 mm</span>
        </div>
      </div>

      <div style="margin-top:6px">
        <div class="section-title">Commands</div>
        <div class="btn-row">
          <button class="btn" id="btnPowerOn">Power On</button>
          <button class="btn" id="btnPowerOff">Power Off</button>
          <button class="btn" id="btnEnable">Enable</button>
          <button class="btn" id="btnDisable">Disable</button>
        </div>
      </div>

      <div style="margin-top:6px">
        <div class="section-title">Tasks</div>
        <div class="btn-row">
          <button class="btn" id="btnTaskHome">Home</button>
          <button class="btn" id="btnTaskReady">Ready</button>
          <button class="btn" id="btnTaskWave">Wave</button>
          <button class="btn" id="btnTaskStop" style="border-color:var(--warning);color:var(--warning)">Stop Task</button>
        </div>
      </div>

      <button class="estop" id="btnEstop">‚ö† EMERGENCY STOP</button>

      <div class="section-title">Raw Command</div>
      <div class="raw-cmd">
        <input type="text" id="rawInput" placeholder='{"action":"set-joint","id":0,"angle":45}'>
        <button class="btn" id="btnRawSend">Send</button>
      </div>
    </div>
  </div>
</div>

<div class="log-panel">
  <div class="log-title">Action Log</div>
  <div class="log-scroll" id="logScroll"></div>
</div>

</div><!-- /tabControl -->

<div class="tab-content" id="tabAscii">
<div class="ascii-tab-wrap">
  <div class="ascii-controls-bar">
    <label>CHARS</label>
    <select id="ascCharset"><option value="standard">Standard</option><option value="detailed">Detailed</option><option value="blocks">Blocks</option><option value="minimal">Minimal</option></select>
    <label>W</label><input type="number" id="ascWidth" value="160" min="20" max="300" step="10">
    <label>H</label><input type="number" id="ascHeight" value="70" min="10" max="150" step="5">
    <button class="ascii-toggle" id="ascColor">COLOR</button>
    <button class="ascii-toggle on" id="ascInvert">INVERT</button>
    <button class="ascii-toggle" id="ascPause">PAUSE</button>
  </div>
  <div class="ascii-status-bar">
    <span class="ascii-status-dot" id="ascDot0"></span>
    <span>CAM0</span>
    <span class="ascii-status-dot" id="ascDot1" style="margin-left:8px"></span>
    <span>CAM1</span>
    <span style="flex:1"></span>
    <span id="ascFps">-- fps</span>
  </div>
  <div class="ascii-viewport" id="asciiViewport">
    <div class="ascii-pane">
      <div class="ascii-pane-label">üì∑ CAM 0 ‚Äî Front</div>
      <pre id="asciiOutput0">Waiting for stream...</pre>
    </div>
    <div class="ascii-divider"></div>
    <div class="ascii-pane">
      <div class="ascii-pane-label">üì∑ CAM 1 ‚Äî Overhead</div>
      <pre id="asciiOutput1">Waiting for stream...</pre>
    </div>
  </div>
</div>
</div><!-- /tabAscii -->

<div class="debug-panel" id="debugPanel" style="display:none">
  <div class="debug-section">
    <div class="debug-title">Pipeline</div>
    <div class="debug-pipeline" id="debugPipeline">
      <div class="pipe-stage" data-stage="CMD_SENT"><div class="pipe-dot"></div><div class="pipe-label">CMD</div><div class="pipe-latency" id="plCmd">‚Äî</div></div>
      <div class="pipe-arrow">‚Üí</div>
      <div class="pipe-stage" data-stage="DDS_PUBLISH"><div class="pipe-dot"></div><div class="pipe-label">DDS TX</div><div class="pipe-latency" id="plDdsTx">‚Äî</div></div>
      <div class="pipe-arrow">‚Üí</div>
      <div class="pipe-stage" data-stage="DDS_RECEIVE"><div class="pipe-dot"></div><div class="pipe-label">ARM RX</div><div class="pipe-latency" id="plArmRx">‚Äî</div></div>
      <div class="pipe-arrow">‚Üí</div>
      <div class="pipe-stage" data-stage="CMD_EXEC"><div class="pipe-dot"></div><div class="pipe-label">EXEC</div><div class="pipe-latency" id="plExec">‚Äî</div></div>
      <div class="pipe-arrow">‚Üí</div>
      <div class="pipe-stage" data-stage="STATE_UPDATE"><div class="pipe-dot"></div><div class="pipe-label">STATE</div><div class="pipe-latency" id="plState">‚Äî</div></div>
      <div class="pipe-arrow">‚Üí</div>
      <div class="pipe-stage" data-stage="WS_SEND"><div class="pipe-dot"></div><div class="pipe-label">WS TX</div><div class="pipe-latency" id="plWsTx">‚Äî</div></div>
      <div class="pipe-arrow">‚Üí</div>
      <div class="pipe-stage" data-stage="UI"><div class="pipe-dot"></div><div class="pipe-label">UI</div><div class="pipe-latency" id="plUi">‚Äî</div></div>
    </div>
  </div>
  <div class="debug-section">
    <div class="debug-title">Stats</div>
    <div class="debug-stats" id="debugStats">
      <div class="stat-group"><div class="stat-header">DDS</div><div class="stat-row"><span>TX rate</span><span id="dsTxRate">N/A</span></div><div class="stat-row"><span>RX rate</span><span id="dsRxRate">N/A</span></div><div class="stat-row"><span>Last RX age</span><span id="dsRxAge">N/A</span></div></div>
      <div class="stat-group"><div class="stat-header">Cameras</div><div class="stat-row"><span>C0 FPS</span><span id="dsC0Fps">N/A</span></div><div class="stat-row"><span>C1 FPS</span><span id="dsC1Fps">N/A</span></div><div class="stat-row"><span>Motion</span><span id="dsMotion">N/A</span></div></div>
      <div class="stat-group"><div class="stat-header">WebSocket</div><div class="stat-row"><span>Send rate</span><span id="dsWsSend">N/A</span></div><div class="stat-row"><span>Latency</span><span id="dsWsLat">N/A</span></div><div class="stat-row"><span>RX interval</span><span id="dsWsRxInt">N/A</span></div></div>
      <div class="stat-group"><div class="stat-header">Latency</div><div class="stat-row"><span>Cmd‚ÜíAck</span><span id="dsLatCmdAck">N/A</span></div><div class="stat-row"><span>Ack‚ÜíExec</span><span id="dsLatAckExec">N/A</span></div><div class="stat-row"><span>End-to-end</span><span id="dsLatE2e">N/A</span></div></div>
    </div>
  </div>
  <div class="debug-section">
    <div class="debug-title">Event Stream</div>
    <div class="debug-events" id="debugEvents"></div>
  </div>
</div>

<script>
'use strict';

// ============================================================
//  CONSTANTS & SPECS
// ============================================================

const JOINT_SPECS = [
  { name: 'J0', min: -135, max: 135, label: 'Base Yaw',    type: 'yaw'   },
  { name: 'J1', min: -90,  max: 90,  label: 'Shoulder',    type: 'pitch' },
  { name: 'J2', min: -90,  max: 90,  label: 'Elbow',       type: 'pitch' },
  { name: 'J3', min: -135, max: 135, label: 'Wrist Roll',  type: 'roll'  },
  { name: 'J4', min: -90,  max: 90,  label: 'Wrist Pitch', type: 'pitch' },
  { name: 'J5', min: -135, max: 135, label: 'Wrist Roll',  type: 'roll'  },
];

// D1 link lengths in mm for side-view FK (legacy fallback)
let LINKS_MM = {
  base: 80, shoulder: 170, elbow: 170, wrist1: 60, wrist2: 60, end: 50
};

let CAM_PARAMS = null; // {fx, fy, cx, cy, rx, ry, rz, tx, ty, tz}
let USE_3D_PROJECTION = false; // true when camera calibration is loaded

// --- Geometric FK (empirically verified against real D1 arm) ---
// Returns 5 key positions [x,y,z] in meters: base, shoulder, elbow, wrist, EE
// Coordinate frame: Z=up, X=forward (arm extends +X at home), Y=left
// Joint conventions (from empirical mapping):
//   J0: base yaw (+CCW from above)
//   J1: shoulder pitch (+UP/backward, applied as -Ry)
//   J2: elbow pitch (+straightens arm, applied as -Ry from 90¬∞ home bend)
//   J3: forearm roll (+CW looking down arm)
//   J4: wrist pitch (+gripper down, applied as +Ry)
//   J5: gripper roll (+CW from above)
function fkPositions(jointsDeg) {
  const D = Math.PI / 180;
  const j = jointsDeg.map(v => (v || 0) * D);
  const d0 = 0.1215, L1 = 0.2085, L2 = 0.2085, L3 = 0.1130;

  // Rotation helpers (return 3x3 as flat [9])
  function rz(a) { const c=Math.cos(a),s=Math.sin(a); return [c,-s,0, s,c,0, 0,0,1]; }
  function ry(a) { const c=Math.cos(a),s=Math.sin(a); return [c,0,s, 0,1,0, -s,0,c]; }
  function mul(A,B) {
    const C = new Array(9);
    for (let r=0;r<3;r++) for (let c=0;c<3;c++)
      C[r*3+c] = A[r*3]*B[c] + A[r*3+1]*B[3+c] + A[r*3+2]*B[6+c];
    return C;
  }
  function apply(R, v) {
    return [R[0]*v[0]+R[1]*v[1]+R[2]*v[2],
            R[3]*v[0]+R[4]*v[1]+R[5]*v[2],
            R[6]*v[0]+R[7]*v[1]+R[8]*v[2]];
  }
  function vadd(a,b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }

  const base = [0, 0, 0];
  const shoulder = [0, 0, d0];

  let R = mul(rz(j[0]), ry(j[1]));                // J0 yaw + J1 pitch (sign flipped)
  const elbow = vadd(shoulder, apply(R, [0,0,L1]));

  R = mul(R, ry(Math.PI/2 + j[2]));               // 90¬∞ home bend + J2 (sign flipped)
  const wrist = vadd(elbow, apply(R, [0,0,L2]));

  R = mul(R, rz(j[3]));                           // J3 forearm roll
  R = mul(R, ry(j[4]));                           // J4 wrist pitch
  const ee = vadd(wrist, apply(R, [0,0,L3]));

  return [base, shoulder, elbow, wrist, ee];
}

function rodrigues(rv) {
  // Rodrigues vector [rx,ry,rz] -> 3x3 rotation matrix
  const angle = Math.sqrt(rv[0]*rv[0]+rv[1]*rv[1]+rv[2]*rv[2]);
  if (angle < 1e-8) return [[1,0,0],[0,1,0],[0,0,1]];
  const k = [rv[0]/angle, rv[1]/angle, rv[2]/angle];
  const c = Math.cos(angle), s = Math.sin(angle), v = 1-c;
  return [
    [k[0]*k[0]*v+c,       k[0]*k[1]*v-k[2]*s, k[0]*k[2]*v+k[1]*s],
    [k[1]*k[0]*v+k[2]*s,  k[1]*k[1]*v+c,       k[1]*k[2]*v-k[0]*s],
    [k[2]*k[0]*v-k[1]*s,  k[2]*k[1]*v+k[0]*s,  k[2]*k[2]*v+c      ]
  ];
}

function projectPoint3D(p3d, cam) {
  // p3d: [x,y,z], cam: {fx,fy,cx,cy,rx,ry,rz,tx,ty,tz}
  const R = rodrigues([cam.rx, cam.ry, cam.rz]);
  const pc = [
    R[0][0]*p3d[0]+R[0][1]*p3d[1]+R[0][2]*p3d[2]+cam.tx,
    R[1][0]*p3d[0]+R[1][1]*p3d[1]+R[1][2]*p3d[2]+cam.ty,
    R[2][0]*p3d[0]+R[2][1]*p3d[1]+R[2][2]*p3d[2]+cam.tz
  ];
  if (pc[2] <= 0) return null;
  return [cam.fx * pc[0]/pc[2] + cam.cx, cam.fy * pc[1]/pc[2] + cam.cy];
}

// Load camera calibration if available (for 3D projection mode)
(async function loadVizCalibration() {
  try {
    const resp = await fetch('/api/viz/calibration');
    if (resp.ok) {
      const data = await resp.json();
      if (data.ok && data.camera_params) {
        const cam = data.camera_params.cam1 || data.camera_params.cam0;
        if (cam) {
          CAM_PARAMS = cam;
          USE_3D_PROJECTION = true;
          console.log('Camera calibration loaded for 3D projection:', cam);
        }
      }
    }
  } catch (e) { console.log('No viz calibration available'); }
})();

// ============================================================
//  STATE
// ============================================================

let ws = null;
let armState = { connected: false, joints: [0,0,0,0,0,0], gripper: 0, power: false, enabled: false, error: 0, log: [] };
let lastStateTs = 0;
let userDragging = -1;           // -1=none, 0-5=joint, 6=gripper
let animFrameId = null;
let localLog = [];               // Client-side log entries
let armSynced = false;           // SAFETY: don't send commands until first state received
let updatingFromState = false;   // Guard against state‚Üíslider‚Üícommand feedback loop
let vizDirty = true;             // Only redraw when state changes
let lastGoodJoints = [0,0,0,0,0,0]; // Client-side cache to prevent zero-snap
let vizJoints = [0,0,0,0,0,0];  // Smoothed joints actually rendered
let jointSource = 'init';        // Telemetry: where current joint values came from
let wsUpdateCount = 0;           // Telemetry: count of WS updates received

// ============================================================
//  UTILITIES
// ============================================================

function logLocal(action, details, level) {
  const now = new Date();
  const ts_str = now.toTimeString().slice(0,8) + '.' + String(now.getMilliseconds()).padStart(3,'0');
  localLog.push({ ts_str, action, details, level });
  if (localLog.length > 100) localLog.shift();
}

function esc(s) {
  if (!s) return '';
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

function makeThrottle(fn, ms = 50) {
  let lastCall = 0, timer = null;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= ms) {
      lastCall = now;
      fn(...args);
    } else {
      clearTimeout(timer);
      timer = setTimeout(() => { lastCall = Date.now(); fn(...args); }, ms - (now - lastCall));
    }
  };
}

// ============================================================
//  SLIDER SETUP (Joint + Gripper)
// ============================================================

const slidersDiv = document.getElementById('jointSliders');
for (let i = 0; i < 6; i++) {
  const spec = JOINT_SPECS[i];
  const row = document.createElement('div');
  row.className = 'joint-row';
  row.innerHTML = `
    <span class="joint-label">${spec.name}</span>
    <input type="range" class="joint-slider" id="js${i}" min="${spec.min}" max="${spec.max}" step="0.5" value="0">
    <span class="joint-value" id="jv${i}">0.0¬∞</span>
  `;
  slidersDiv.appendChild(row);

  const slider = row.querySelector('input');
  slider.addEventListener('mousedown', () => userDragging = i);
  slider.addEventListener('touchstart', () => userDragging = i);
  slider.addEventListener('input', () => {
    document.getElementById(`jv${i}`).textContent = parseFloat(slider.value).toFixed(1) + '¬∞';
    if (!armSynced || updatingFromState) return;
    throttledSendJoint(i, parseFloat(slider.value));
  });
  const release = () => { if (userDragging === i) { sendJoint(i, parseFloat(slider.value)); userDragging = -1; } };
  slider.addEventListener('mouseup', release);
  slider.addEventListener('touchend', release);
  slider.addEventListener('change', release);
}

const gripSlider = document.getElementById('gripperSlider');
gripSlider.addEventListener('mousedown', () => userDragging = 6);
gripSlider.addEventListener('touchstart', () => userDragging = 6);
gripSlider.addEventListener('input', () => {
  document.getElementById('gripperValue').textContent = parseFloat(gripSlider.value).toFixed(1) + ' mm';
  if (!armSynced || updatingFromState) return;
  throttledSendGripper(parseFloat(gripSlider.value));
});
const gripRelease = () => { if (userDragging === 6) { sendGripper(parseFloat(gripSlider.value)); userDragging = -1; } };
gripSlider.addEventListener('mouseup', gripRelease);
gripSlider.addEventListener('touchend', gripRelease);
gripSlider.addEventListener('change', gripRelease);

const throttledSendJoint = makeThrottle((id, angle) => sendJoint(id, angle), 50);
const throttledSendGripper = makeThrottle((pos) => sendGripper(pos), 50);

// ============================================================
//  COMMANDS (API calls)
// ============================================================

async function cmd(action) {
  logLocal(action.toUpperCase(), `Sending POST /api/command/${action}`, 'info');
  try {
    const resp = await fetch(`/api/command/${action}`, { method: 'POST' });
    const data = await resp.json();
    if (data.ok) {
      logLocal(action.toUpperCase(), '‚úì Success', 'info');
    } else {
      logLocal(action.toUpperCase(), `‚úó Failed: ${data.error || 'unknown'}`, 'error');
    }
    if (data.state) { armState = { ...armState, ...data.state }; vizDirty = true; }
    updateUI();
  } catch(e) {
    logLocal(action.toUpperCase(), `‚úó Network error: ${e.message}`, 'error');
  }
}

async function sendJoint(id, angle) {
  if (!armSynced) return;
  logLocal('SET_JOINT', `J${id} -> ${angle.toFixed(1)}¬∞`, 'info');
  try {
    const resp = await fetch('/api/command/set-joint', {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id, angle })
    });
    const data = await resp.json();
    if (!data.ok) logLocal('SET_JOINT', `‚úó ${data.error || 'failed'}`, 'error');
  } catch(e) { logLocal('SET_JOINT', `‚úó ${e.message}`, 'error'); }
}

async function sendGripper(pos) {
  if (!armSynced) return;
  logLocal('SET_GRIPPER', `${pos.toFixed(1)} mm`, 'info');
  try {
    const resp = await fetch('/api/command/set-gripper', {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ position: pos })
    });
    const data = await resp.json();
    if (!data.ok) logLocal('SET_GRIPPER', `‚úó ${data.error || 'failed'}`, 'error');
  } catch(e) { logLocal('SET_GRIPPER', `‚úó ${e.message}`, 'error'); }
}

async function runTask(name, body = {}) {
  logLocal('TASK', `Starting task: ${name}`, 'info');
  try {
    const resp = await fetch(`/api/task/${name}`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)
    });
    const data = await resp.json();
    if (data.ok) {
      logLocal('TASK', `${name}: ${data.points} pts, ${data.duration_s}s`, 'info');
    } else {
      logLocal('TASK', `${name}: ${data.error || 'failed'}`, 'error');
    }
  } catch(e) { logLocal('TASK', `${name}: ${e.message}`, 'error'); }
}

// ============================================================
//  BUTTON WIRING
// ============================================================

document.getElementById('btnPowerOn').addEventListener('click', () => cmd('power-on'));
document.getElementById('btnPowerOff').addEventListener('click', () => cmd('power-off'));
document.getElementById('btnEnable').addEventListener('click', () => cmd('enable'));
document.getElementById('btnDisable').addEventListener('click', () => cmd('disable'));
document.getElementById('btnTaskHome').addEventListener('click', () => runTask('home'));
document.getElementById('btnTaskReady').addEventListener('click', () => runTask('ready'));
document.getElementById('btnTaskWave').addEventListener('click', () => runTask('wave'));
document.getElementById('btnTaskStop').addEventListener('click', () => runTask('stop'));
document.getElementById('btnEstop').addEventListener('click', () => cmd('stop'));

document.getElementById('btnRawSend').addEventListener('click', async () => {
  const raw = document.getElementById('rawInput').value.trim();
  if (!raw) return;
  logLocal('RAW', `Sending: ${raw}`, 'warning');
  try {
    const parsed = JSON.parse(raw);
    const action = parsed.action || 'set-joint';
    delete parsed.action;
    const resp = await fetch(`/api/command/${action}`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(parsed)
    });
    const data = await resp.json();
    logLocal('RAW', `Response: ${JSON.stringify(data).slice(0,120)}`, data.ok ? 'info' : 'error');
  } catch(e) { logLocal('RAW', `Error: ${e.message}`, 'error'); }
});
document.getElementById('rawInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') document.getElementById('btnRawSend').click(); });

// ============================================================
//  WEBSOCKET
// ============================================================

function connectWS() {
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${proto}//${location.host}/ws/state`);
  ws.onopen = () => { updateConn(true); logLocal('WS', 'Connected', 'info'); };
  ws.onclose = () => { updateConn(false); setTimeout(connectWS, 2000); };
  ws.onerror = () => ws.close();
  ws.onmessage = (e) => {
    try {
      const data = JSON.parse(e.data);
      if (data.type === 'ack') {
        logLocal('ACK', `${data.action}: ${data.ok ? 'OK' : 'FAIL'}`, data.ok ? 'info' : 'error');
        return;
      }
      if (data.type === 'collision') {
        showCollisionAlert(data);
        logLocal('COLLISION', `‚ö† J${data.joint} stalled: cmd=${data.commanded}¬∞ actual=${data.actual}¬∞`, 'error');
        return;
      }

      // Zero-snap protection: if server sends all-zero joints but we had real values, keep cached
      const newJoints = data.joints || [0,0,0,0,0,0];
      const allZero = newJoints.every(v => Math.abs(v) < 0.01);
      const hadReal = lastGoodJoints.some(v => Math.abs(v) > 0.1);
      if (allZero && hadReal && armSynced) {
        data.joints = lastGoodJoints.slice();
        jointSource = 'cached (zero-snap blocked)';
      } else {
        lastGoodJoints = newJoints.slice();
        jointSource = 'ws';
      }

      // Only mark dirty if joints actually changed meaningfully (>0.05¬∞ on any joint)
      const jointsDiff = newJoints.some((v, i) => Math.abs(v - vizJoints[i]) > 0.05);
      const otherChanged = data.power !== armState.power || data.enabled !== armState.enabled || data.error !== armState.error;

      armState = data;
      lastStateTs = Date.now();
      wsUpdateCount++;
      if (jointsDiff || otherChanged || !armSynced) vizDirty = true;
      if (!armSynced) {
        armSynced = true;
        logLocal('SYNC', 'First arm state received ‚Äî sliders synced', 'info');
      }
    } catch(err) {}
  };
}

function updateConn(on) {
  document.getElementById('connDot').className = 'conn-dot ' + (on ? 'on' : 'off');
  document.getElementById('connLabel').textContent = on ? 'CONNECTED' : 'DISCONNECTED';
}

// ============================================================
//  UI UPDATE & LOG RENDERING
// ============================================================

function updateUI() {
  // Badges
  const bp = document.getElementById('badgePower');
  bp.textContent = armState.power ? 'PWR ON' : 'PWR OFF';
  bp.className = 'badge' + (armState.power ? ' active' : '');

  const be = document.getElementById('badgeEnabled');
  be.textContent = armState.enabled ? 'ENABLED' : 'DISABLED';
  be.className = 'badge' + (armState.enabled ? ' active' : '');

  const berr = document.getElementById('badgeError');
  if (armState.error) { berr.textContent = 'ERR ' + armState.error; berr.className = 'badge error'; }
  else { berr.textContent = 'NO ERR'; berr.className = 'badge'; }

  // Connection quality
  if (lastStateTs > 0) {
    const age = Date.now() - lastStateTs;
    const q = document.getElementById('connQuality');
    if (age < 500) q.textContent = '‚óè live';
    else if (age < 2000) q.textContent = `‚óè ${(age/1000).toFixed(1)}s ago`;
    else q.textContent = `‚ö† ${(age/1000).toFixed(0)}s stale`;
    q.style.color = age < 500 ? 'var(--success)' : age < 2000 ? 'var(--warning)' : 'var(--danger)';
  }

  // Button states
  document.getElementById('btnPowerOn').disabled = armState.power;
  document.getElementById('btnPowerOn').className = 'btn' + (armState.power ? ' on' : '');
  document.getElementById('btnPowerOff').disabled = !armState.power;
  document.getElementById('btnEnable').disabled = !armState.power || armState.enabled;
  document.getElementById('btnEnable').className = 'btn' + (armState.enabled ? ' on' : '');
  document.getElementById('btnDisable').disabled = !armState.enabled;

  // E-stop flash when enabled
  document.getElementById('btnEstop').className = armState.enabled ? 'estop flash' : 'estop';

  // Joint sliders ‚Äî dead-band update to prevent jitter, guarded against feedback loops
  updatingFromState = true;
  const joints = armState.joints || [0,0,0,0,0,0];
  for (let i = 0; i < 6; i++) {
    if (userDragging !== i) {
      const val = joints[i] || 0;
      const slider = document.getElementById(`js${i}`);
      const current = parseFloat(slider.value);
      if (Math.abs(current - val) > 0.25) slider.value = val;
      const label = document.getElementById(`jv${i}`);
      const txt = val.toFixed(1) + '¬∞';
      if (label.textContent !== txt) label.textContent = txt;
    }
  }

  // Gripper slider ‚Äî same dead-band guard
  if (userDragging !== 6) {
    const gv = armState.gripper || 0;
    const current = parseFloat(gripSlider.value);
    if (Math.abs(current - gv) > 0.25) gripSlider.value = gv;
    const gLabel = document.getElementById('gripperValue');
    const gTxt = gv.toFixed(1) + ' mm';
    if (gLabel.textContent !== gTxt) gLabel.textContent = gTxt;
  }
  updatingFromState = false;

  renderLog();
}

let lastLogHash = '';
function renderLog() {
  const serverEntries = (armState.log || []).map(e => ({
    ts_str: e.ts_str, action: e.action, details: e.details, level: e.level, src: 's'
  }));
  const all = [...serverEntries, ...localLog.map(e => ({ ...e, src: 'c' }))];
  all.sort((a, b) => a.ts_str.localeCompare(b.ts_str));
  const last40 = all.slice(-40);

  const hash = last40.map(e => e.ts_str + e.action).join('|');
  if (hash === lastLogHash) return;
  lastLogHash = hash;

  const el = document.getElementById('logScroll');
  el.innerHTML = last40.map(e =>
    `<div class="log-entry ${e.level}"><span class="ts">${esc(e.ts_str)}</span><span class="act">${esc(e.action)}</span><span class="detail">${esc(e.details)}</span></div>`
  ).join('');
  el.scrollTop = el.scrollHeight;
}

// ============================================================
//  ARM VISUALIZATION (Canvas FK)
// ============================================================

const canvas = document.getElementById('armCanvas');
const ctx = canvas.getContext('2d');

function drawArm() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  const rawJoints = armState.joints || [0,0,0,0,0,0];
  // Smooth viz joints ‚Äî lerp toward target to reduce jitter
  for (let i = 0; i < 6; i++) {
    const diff = rawJoints[i] - vizJoints[i];
    if (Math.abs(diff) > 0.05) {
      vizJoints[i] += diff * 0.4;
    } else {
      vizJoints[i] = rawJoints[i];
    }
  }
  const joints = vizJoints;
  const deg2rad = Math.PI / 180;

  // Grid
  ctx.strokeStyle = 'rgba(42,74,124,0.12)';
  ctx.lineWidth = 1;
  for (let y = 0; y < H; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
  for (let x = 0; x < W; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }

  // FK chain ‚Äî either 3D projection (v2) or legacy 2D side-view
  const scale = Math.min(W, H) / 900;
  const baseX = W * 0.35, baseY = H * 0.85;

  // Base platform
  ctx.fillStyle = '#1a2744';
  ctx.strokeStyle = '#2a4a7c';
  ctx.lineWidth = 1;
  const bw = 60 * scale, bh = 15 * scale;
  ctx.fillRect(baseX - bw, baseY, bw * 2, bh);
  ctx.strokeRect(baseX - bw, baseY, bw * 2, bh);

  let pts;

  // Geometric FK ‚Äî empirically verified against real D1 arm
  const fkPos = fkPositions(joints);  // 5 positions: base, shoulder, elbow, wrist, EE

  if (USE_3D_PROJECTION && CAM_PARAMS) {
    // --- 3D FK + Camera Projection (v2) ---
    const projected = fkPos.map(p => projectPoint3D(p, CAM_PARAMS));
    const camW = 1920, camH = 1080;
    pts = projected.map(p => {
      if (!p) return { x: baseX, y: baseY };
      return { x: p[0] * (W / camW), y: p[1] * (H / camH) };
    });
  } else {
    // --- Orthographic side-view of 3D FK ---
    // Project onto the arm's plane (rotate by J0 so we always see the arm from the side)
    const j0rad = (joints[0] || 0) * deg2rad;
    const cosJ0 = Math.cos(j0rad), sinJ0 = Math.sin(j0rad);
    const mToPixel = 700 * scale; // meters to pixels
    pts = fkPos.map(p => {
      const radial = p[0] * cosJ0 + p[1] * sinJ0;
      const height = p[2];
      return {
        x: baseX + radial * mToPixel,
        y: baseY - height * mToPixel
      };
    });
  }

  // Draw links (5 pts = 4 segments: base‚Üíshoulder‚Üíelbow‚Üíwrist‚ÜíEE)
  const linkColors = ['#2a4a7c', '#4a90d9', '#3a7abd', '#2a6aad'];
  const linkWidths = [10, 8, 6, 4];
  ctx.lineCap = 'round';
  for (let i = 0; i < pts.length - 1; i++) {
    ctx.strokeStyle = linkColors[i] || '#4a90d9';
    ctx.lineWidth = linkWidths[i] * scale * 1.2;
    ctx.beginPath();
    ctx.moveTo(pts[i].x, pts[i].y);
    ctx.lineTo(pts[i+1].x, pts[i+1].y);
    ctx.stroke();
  }

  // Draw joints
  for (let i = 0; i < pts.length; i++) {
    const r = (i === 0 ? 10 : i === pts.length - 1 ? 5 : 7) * scale;
    ctx.beginPath();
    ctx.arc(pts[i].x, pts[i].y, r + 3 * scale, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(15,52,96,0.3)';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(pts[i].x, pts[i].y, r, 0, Math.PI * 2);
    ctx.fillStyle = '#16213e';
    ctx.fill();
    ctx.strokeStyle = '#4a90d9';
    ctx.lineWidth = 2 * scale;
    ctx.stroke();
  }

  // Roll joint rotation indicators
  const rollColor = '#e8a838';
  const pitchColor = '#4a90d9';

  function drawRotationIndicator(cx, cy, radius, angleDeg, label) {
    const a = angleDeg * deg2rad;
    const r = radius * scale;
    // Background ring
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(232,168,56,0.15)';
    ctx.lineWidth = 3 * scale;
    ctx.stroke();
    // Zero tick
    ctx.beginPath();
    ctx.moveTo(cx, cy - r + 2 * scale);
    ctx.lineTo(cx, cy - r - 3 * scale);
    ctx.strokeStyle = 'rgba(232,168,56,0.4)';
    ctx.lineWidth = 1.5 * scale;
    ctx.stroke();
    // Filled arc
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + a, a < 0);
    ctx.closePath();
    ctx.fillStyle = Math.abs(angleDeg) > 100 ? 'rgba(233,69,96,0.2)' : 'rgba(232,168,56,0.15)';
    ctx.fill();
    // Arc stroke
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + a, a < 0);
    ctx.strokeStyle = Math.abs(angleDeg) > 100 ? '#e94560' : rollColor;
    ctx.lineWidth = 3.5 * scale;
    ctx.stroke();
    // Endpoint dot
    const ex = cx + Math.cos(-Math.PI / 2 + a) * r;
    const ey = cy + Math.sin(-Math.PI / 2 + a) * r;
    ctx.beginPath();
    ctx.arc(ex, ey, 4 * scale, 0, Math.PI * 2);
    ctx.fillStyle = Math.abs(angleDeg) > 100 ? '#e94560' : rollColor;
    ctx.fill();
    // Label
    const lx = cx + (r + 6 * scale);
    const ly = cy + (4 * scale);
    ctx.font = `bold ${10 * scale}px JetBrains Mono, monospace`;
    ctx.fillStyle = rollColor;
    ctx.fillText(`${label} ${angleDeg.toFixed(1)}¬∞`, lx, ly);
    ctx.font = `${7 * scale}px JetBrains Mono, monospace`;
    ctx.fillStyle = 'rgba(232,168,56,0.5)';
    ctx.fillText('roll', lx, ly + 10 * scale);
  }

  // J0 base rotation ‚Äî top-down mini view in upper-right corner
  const j0Angle = joints[0] || 0;
  const j0cx = W - 50 * scale, j0cy = 50 * scale, j0r = 30 * scale;
  ctx.beginPath();
  ctx.arc(j0cx, j0cy, j0r + 2 * scale, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(26,39,68,0.6)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(232,168,56,0.3)';
  ctx.lineWidth = 1.5 * scale;
  ctx.stroke();
  // Compass ticks
  for (let t = 0; t < 4; t++) {
    const ta = t * Math.PI / 2;
    ctx.beginPath();
    ctx.moveTo(j0cx + Math.cos(ta) * (j0r - 3 * scale), j0cy + Math.sin(ta) * (j0r - 3 * scale));
    ctx.lineTo(j0cx + Math.cos(ta) * (j0r + 2 * scale), j0cy + Math.sin(ta) * (j0r + 2 * scale));
    ctx.strokeStyle = 'rgba(232,168,56,0.25)';
    ctx.lineWidth = 1 * scale;
    ctx.stroke();
  }
  // Direction line
  const j0a = j0Angle * deg2rad;
  ctx.beginPath();
  ctx.moveTo(j0cx, j0cy);
  ctx.arc(j0cx, j0cy, j0r, -Math.PI / 2, -Math.PI / 2 + j0a, j0a < 0);
  ctx.closePath();
  ctx.fillStyle = Math.abs(j0Angle) > 100 ? 'rgba(233,69,96,0.2)' : 'rgba(232,168,56,0.15)';
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(j0cx, j0cy);
  ctx.lineTo(j0cx + Math.sin(j0a) * j0r * 0.85, j0cy - Math.cos(j0a) * j0r * 0.85);
  ctx.strokeStyle = Math.abs(j0Angle) > 100 ? '#e94560' : rollColor;
  ctx.lineWidth = 3 * scale;
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(j0cx, j0cy, 3 * scale, 0, Math.PI * 2);
  ctx.fillStyle = rollColor;
  ctx.fill();
  // J0 label
  ctx.font = `bold ${10 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = rollColor;
  ctx.textAlign = 'center';
  ctx.fillText(`J0 ${j0Angle.toFixed(1)}¬∞`, j0cx, j0cy + j0r + 14 * scale);
  ctx.font = `${7 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = 'rgba(232,168,56,0.5)';
  ctx.fillText('base rotation (top view)', j0cx, j0cy + j0r + 24 * scale);
  ctx.textAlign = 'left';

  // Points: [0]=base, [1]=shoulder, [2]=elbow, [3]=wrist, [4]=EE
  // Roll indicators at elbow (J3) and wrist (J5)
  drawRotationIndicator(pts[2].x, pts[2].y, 22, joints[3] || 0, 'J3');
  drawRotationIndicator(pts[3].x, pts[3].y, 18, joints[5] || 0, 'J5');

  // Pitch joint labels: J1 at shoulder, J2 at elbow, J4 at wrist
  ctx.font = `bold ${10 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = pitchColor;
  ctx.fillText(`J1 ${(joints[1]||0).toFixed(1)}¬∞`, pts[1].x - 55 * scale, pts[1].y - 12 * scale);
  ctx.font = `${7 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = 'rgba(74,144,217,0.5)';
  ctx.fillText('pitch', pts[1].x - 55 * scale, pts[1].y - 2 * scale);

  ctx.font = `bold ${10 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = pitchColor;
  ctx.fillText(`J2 ${(joints[2]||0).toFixed(1)}¬∞`, pts[2].x + 12 * scale, pts[2].y - 12 * scale);
  ctx.font = `${7 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = 'rgba(74,144,217,0.5)';
  ctx.fillText('pitch', pts[2].x + 12 * scale, pts[2].y - 2 * scale);

  ctx.font = `bold ${10 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = pitchColor;
  ctx.fillText(`J4 ${(joints[4]||0).toFixed(1)}¬∞`, pts[3].x + 12 * scale, pts[3].y - 12 * scale);
  ctx.font = `${7 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = 'rgba(74,144,217,0.5)';
  ctx.fillText('pitch', pts[3].x + 12 * scale, pts[3].y - 2 * scale);

  // Gripper visualization
  const tip = pts[pts.length - 1];
  // Compute gripper angle from the last two FK points (end-effector direction)
  const prevPt = pts[pts.length - 2];
  const gAngle = Math.atan2(tip.y - prevPt.y, tip.x - prevPt.x);
  const gripMM = armState.gripper != null ? armState.gripper : 0;
  const gripRatio = Math.min(gripMM / 65, 1);
  const gOpen = gripRatio * 12 * scale;
  const fingerLen = 20 * scale;
  const fingerWid = 4 * scale;
  const gR = Math.round(233 - gripRatio * 150);
  const gG = Math.round(120 + gripRatio * 95);
  const gB = Math.round(56 + gripRatio * 50);
  const gripCol = `rgb(${gR},${gG},${gB})`;

  for (const side of [-1, 1]) {
    const perpX = Math.cos(gAngle + Math.PI / 2) * side * gOpen;
    const perpY = Math.sin(gAngle + Math.PI / 2) * side * gOpen;
    const fx1 = tip.x + perpX;
    const fy1 = tip.y + perpY;
    const fx2 = fx1 + Math.cos(gAngle) * fingerLen;
    const fy2 = fy1 + Math.sin(gAngle) * fingerLen;
    ctx.beginPath();
    ctx.moveTo(fx1, fy1);
    ctx.lineTo(fx2, fy2);
    ctx.strokeStyle = gripCol;
    ctx.lineWidth = fingerWid;
    ctx.lineCap = 'round';
    ctx.stroke();
    const tipNubX = fx2 + Math.cos(gAngle + Math.PI / 2) * (-side) * 3 * scale;
    const tipNubY = fy2 + Math.sin(gAngle + Math.PI / 2) * (-side) * 3 * scale;
    ctx.beginPath();
    ctx.moveTo(fx2, fy2);
    ctx.lineTo(tipNubX, tipNubY);
    ctx.strokeStyle = gripCol;
    ctx.lineWidth = 3 * scale;
    ctx.stroke();
  }
  // Gripper readout
  ctx.font = `bold ${10 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = gripCol;
  ctx.fillText(`Grip ${gripMM.toFixed(1)}mm`, tip.x + 20 * scale, tip.y + 18 * scale);
  ctx.font = `${7 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = gripRatio > 0.5 ? 'rgba(83,215,105,0.6)' : 'rgba(233,69,96,0.6)';
  ctx.fillText(gripRatio > 0.7 ? 'open' : gripRatio < 0.15 ? 'closed' : 'partial', tip.x + 20 * scale, tip.y + 28 * scale);

  // Title
  ctx.font = `${10 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = 'rgba(136,146,164,0.5)';
  ctx.fillText('D1 Arm ‚Äî DH FK (blue=pitch, gold=roll)', 8, 16 * scale);

  // Telemetry overlay
  ctx.font = `${8 * scale}px JetBrains Mono, monospace`;
  ctx.fillStyle = 'rgba(136,146,164,0.4)';
  const jStr = joints.map(v => v.toFixed(1)).join(', ');
  ctx.fillText(`src:${jointSource} ws#${wsUpdateCount} [${jStr}]`, 8, H - 8 * scale);
}

// ============================================================
//  ANIMATION & RESIZE
// ============================================================

function animLoop() {
  if (vizDirty) {
    vizDirty = false;
    updateUI();
    drawArm();
  }
  animFrameId = requestAnimationFrame(animLoop);
}

function resizeCanvas() {
  const cont = canvas.parentElement;
  const w = cont.clientWidth - 16;
  const h = cont.clientHeight - 16;
  canvas.width = Math.max(w, 300);
  canvas.height = Math.max(h, 250);
  vizDirty = true;
}
window.addEventListener('resize', resizeCanvas);

// ============================================================
//  CAMERA TOGGLE
// ============================================================

document.getElementById('btnCamToggle').addEventListener('click', () => {
  const feeds = document.getElementById('cameraFeeds');
  const btn = document.getElementById('btnCamToggle');
  const hidden = feeds.classList.toggle('hidden');
  btn.textContent = hidden ? 'üëÅ SHOW' : 'üëÅ HIDE';
  const imgs = feeds.querySelectorAll('.cam-img');
  imgs.forEach((img, i) => {
    if (hidden) { img.dataset.src = img.src; img.src = ''; }
    else { img.src = img.dataset.src || `http://localhost:8081/cam/${i}`; }
  });
  setTimeout(resizeCanvas, 50);
});

// ============================================================
//  DEBUG TELEMETRY PANEL
// ============================================================

let debugOn = false;
let debugInterval = null;
let wsLastMsgTs = 0;
let wsRxIntervalMs = 0;

function hookWsDebug() {
  if (!ws) return;
  const origHandler = ws.onmessage;
  ws.onmessage = (e) => {
    const now = Date.now();
    if (wsLastMsgTs > 0) wsRxIntervalMs = now - wsLastMsgTs;
    wsLastMsgTs = now;
    origHandler(e);
  };
}

document.getElementById('btnCalibrateViz').addEventListener('click', async () => {
  const btn = document.getElementById('btnCalibrateViz');
  if (!confirm('This will move the arm through ~20 poses to calibrate the visualization. The arm must be powered and enabled. Continue?')) return;
  btn.disabled = true;
  btn.textContent = 'üìê CALIBRATING...';
  try {
    const resp = await fetch('/api/viz/calibrate', { method: 'POST' });
    const data = await resp.json();
    if (data.ok) {
      if (data.camera_params) {
        CAM_PARAMS = data.camera_params.cam1 || data.camera_params.cam0 || null;
        if (CAM_PARAMS) USE_3D_PROJECTION = true;
      }
      alert(`Calibration complete! ${data.n_observations} observations, residual: ${data.residual}`);
    } else {
      alert('Calibration failed: ' + (data.error || data.message || 'Unknown error'));
    }
  } catch (e) {
    alert('Calibration error: ' + e.message);
  } finally {
    btn.disabled = false;
    btn.textContent = 'üìê CALIBRATE VIZ';
  }
});

document.getElementById('btnDebug').addEventListener('click', async () => {
  debugOn = !debugOn;
  const btn = document.getElementById('btnDebug');
  const panel = document.getElementById('debugPanel');
  btn.className = 'btn' + (debugOn ? ' on' : '');
  panel.style.display = debugOn ? 'block' : 'none';
  try { await fetch(`/api/debug/${debugOn ? 'enable' : 'disable'}`, { method: 'POST' }); } catch(e) {}
  if (debugOn) {
    hookWsDebug();
    debugInterval = setInterval(pollDebug, 1000);
    pollDebug();
  } else {
    if (debugInterval) { clearInterval(debugInterval); debugInterval = null; }
  }
});

async function pollDebug() {
  const panel = document.getElementById('debugPanel');
  if (!debugOn || !panel || panel.style.display === 'none') {
    if (debugInterval) { clearInterval(debugInterval); debugInterval = null; }
    return;
  }
  try {
    const [statsResp, telResp] = await Promise.allSettled([
      fetch('/api/debug/stats'),
      fetch('/api/debug/telemetry?limit=30')
    ]);
    if (statsResp.status === 'fulfilled' && statsResp.value.ok) {
      const stats = await statsResp.value.json();
      updateDebugStats(stats);
    }
    if (telResp.status === 'fulfilled' && telResp.value.ok) {
      const tel = await telResp.value.json();
      updateDebugPipeline(tel.events || tel);
      renderDebugEvents(tel.events || tel);
    }
  } catch(e) {}
  document.getElementById('dsWsRxInt').textContent = wsRxIntervalMs > 0 ? wsRxIntervalMs + 'ms' : 'N/A';
  const uiStage = document.querySelector('.pipe-stage[data-stage="UI"]');
  if (uiStage) { uiStage.className = 'pipe-stage active'; }
}

function updateDebugStats(s) {
  const set = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = v ?? 'N/A'; };
  set('dsTxRate', s.dds_tx_rate != null ? s.dds_tx_rate + '/s' : 'N/A');
  set('dsRxRate', s.dds_rx_rate != null ? s.dds_rx_rate + '/s' : 'N/A');
  set('dsRxAge', s.dds_last_rx_age_ms != null ? s.dds_last_rx_age_ms + 'ms' : 'N/A');
  set('dsC0Fps', s.cam0_fps != null ? s.cam0_fps.toFixed(1) : 'N/A');
  set('dsC1Fps', s.cam1_fps != null ? s.cam1_fps.toFixed(1) : 'N/A');
  set('dsMotion', s.motion_score != null ? s.motion_score.toFixed(2) : 'N/A');
  set('dsWsSend', s.ws_send_rate != null ? s.ws_send_rate + '/s' : 'N/A');
  set('dsWsLat', s.ws_latency_ms != null ? s.ws_latency_ms + 'ms' : 'N/A');
  set('dsLatCmdAck', s.latency_cmd_ack_ms != null ? s.latency_cmd_ack_ms + 'ms' : 'N/A');
  set('dsLatAckExec', s.latency_ack_exec_ms != null ? s.latency_ack_exec_ms + 'ms' : 'N/A');
  set('dsLatE2e', s.latency_e2e_ms != null ? s.latency_e2e_ms + 'ms' : 'N/A');
}

function updateDebugPipeline(events) {
  const now = Date.now();
  const recentTypes = new Set();
  const errorTypes = new Set();
  if (Array.isArray(events)) {
    events.forEach(ev => {
      const age = ev.timestamp ? now - new Date(ev.timestamp).getTime() : 9999;
      if (age < 3000) {
        if (ev.event_type === 'ERROR') errorTypes.add('ERROR');
        else recentTypes.add(ev.event_type);
      }
    });
  }
  document.querySelectorAll('.pipe-stage').forEach(el => {
    const stage = el.dataset.stage;
    if (stage === 'UI') return;
    if (errorTypes.has(stage)) el.className = 'pipe-stage error';
    else if (recentTypes.has(stage)) el.className = 'pipe-stage active';
    else el.className = 'pipe-stage';
  });
}

function renderDebugEvents(events) {
  const container = document.getElementById('debugEvents');
  if (!Array.isArray(events) || events.length === 0) { container.innerHTML = '<div style="color:#555">No events</div>'; return; }
  container.innerHTML = events.map(ev => {
    const ts = ev.timestamp ? new Date(ev.timestamp).toTimeString().slice(0,8) : '??:??:??';
    const cid = ev.correlation_id ? ev.correlation_id.slice(0,8) : '';
    const payload = ev.payload ? JSON.stringify(ev.payload).slice(0,80) : '';
    const typeCls = 'de-' + (ev.event_type || 'CMD_SENT');
    return `<div class="debug-evt"><span class="de-ts">${esc(ts)}</span><span class="de-type ${typeCls}">${esc(ev.event_type||'?')}</span><span class="de-cid">${esc(cid)}</span><span class="de-pay">${esc(payload)}</span></div>`;
  }).join('');
  container.scrollTop = container.scrollHeight;
}

// ============================================================
//  INIT
// ============================================================

connectWS();
setTimeout(() => { resizeCanvas(); animLoop(); }, 50);

// === Collision Alert ===
function showCollisionAlert(data) {
  const el = document.getElementById('collisionAlert');
  document.getElementById('collisionInfo').textContent =
    `Joint ${data.joint} commanded to ${data.commanded}¬∞ but stuck at ${data.actual}¬∞ (error: ${data.error}¬∞)`;
  document.getElementById('collisionAnalysis').textContent = data.analysis || '';
  const imgContainer = document.getElementById('collisionImages');
  imgContainer.innerHTML = '';
  if (data.images) {
    data.images.forEach(src => {
      const img = document.createElement('img');
      img.src = src;
      img.alt = 'Collision snapshot';
      imgContainer.appendChild(img);
    });
  }
  el.classList.add('visible');
}
function dismissCollision() {
  document.getElementById('collisionAlert').classList.remove('visible');
}

// ============================================================
//  TAB SWITCHING
// ============================================================

document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    const tab = btn.dataset.tab;
    document.getElementById(tab === 'ascii' ? 'tabAscii' : 'tabControl').classList.add('active');
    if (tab === 'ascii') { asciiConnect(); }
    else { asciiDisconnect(); }
    if (tab === 'control') setTimeout(resizeCanvas, 50);
  });
});

// ============================================================
//  ASCII VIDEO TAB ‚Äî Dual Camera
// ============================================================

(function() {
  const ascWs = [null, null]; // two WebSocket connections
  const ascReconnectTimers = [null, null];
  let ascPaused = false;
  let ascColorMode = false;
  let ascInvertMode = true;
  let ascFrameCount = 0;
  let ascLastFpsTime = performance.now();

  const ascOutputs = [document.getElementById('asciiOutput0'), document.getElementById('asciiOutput1')];
  const ascDots = [document.getElementById('ascDot0'), document.getElementById('ascDot1')];
  const ascFpsEl = document.getElementById('ascFps');

  function ascSettings(camId) {
    return {
      type: 'settings',
      cam: camId,
      charset: document.getElementById('ascCharset').value,
      width: parseInt(document.getElementById('ascWidth').value) || 160,
      height: parseInt(document.getElementById('ascHeight').value) || 70,
      color: ascColorMode,
      invert: ascInvertMode
    };
  }

  function ascSendSettings(camId) {
    if (ascWs[camId] && ascWs[camId].readyState === 1) {
      ascWs[camId].send(JSON.stringify(ascSettings(camId)));
    }
  }

  function ascSendAllSettings() {
    ascSendSettings(0);
    ascSendSettings(1);
  }

  function renderFrame(camId, data) {
    const out = ascOutputs[camId];
    if (data.colors && ascColorMode) {
      out.classList.add('color-mode');
      out.innerHTML = '';
      const frag = document.createDocumentFragment();
      for (let y = 0; y < data.lines.length; y++) {
        const line = data.lines[y], rowC = data.colors[y];
        for (let x = 0; x < line.length; x++) {
          const sp = document.createElement('span');
          const c = rowC[x];
          sp.style.color = `rgb(${c[0]},${c[1]},${c[2]})`;
          sp.textContent = line[x];
          frag.appendChild(sp);
        }
        frag.appendChild(document.createTextNode('\n'));
      }
      out.appendChild(frag);
    } else {
      out.classList.remove('color-mode');
      out.textContent = data.lines.join('\n');
    }
  }

  function connectCam(camId) {
    if (ascWs[camId] && ascWs[camId].readyState <= 1) return;
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    ascWs[camId] = new WebSocket(`${proto}//${location.host}/ws/ascii`);
    ascDots[camId].className = 'ascii-status-dot';

    ascWs[camId].onopen = () => {
      ascDots[camId].className = 'ascii-status-dot on';
      ascWs[camId].send(JSON.stringify(ascSettings(camId)));
    };
    ascWs[camId].onclose = () => {
      ascDots[camId].className = 'ascii-status-dot';
      ascWs[camId] = null;
      if (document.getElementById('tabAscii').classList.contains('active')) {
        ascReconnectTimers[camId] = setTimeout(() => connectCam(camId), 2000);
      }
    };
    ascWs[camId].onerror = () => {
      ascDots[camId].className = 'ascii-status-dot err';
    };
    ascWs[camId].onmessage = (evt) => {
      if (ascPaused) return;
      const data = JSON.parse(evt.data);
      if (data.type === 'frame') {
        renderFrame(camId, data);
        ascFrameCount++;
        const now = performance.now();
        if (now - ascLastFpsTime >= 1000) {
          ascFpsEl.textContent = (ascFrameCount / ((now - ascLastFpsTime) / 1000)).toFixed(1) + ' fps';
          ascFrameCount = 0;
          ascLastFpsTime = now;
        }
      }
    };
  }

  function disconnectCam(camId) {
    if (ascReconnectTimers[camId]) { clearTimeout(ascReconnectTimers[camId]); ascReconnectTimers[camId] = null; }
    if (ascWs[camId]) { ascWs[camId].onclose = null; ascWs[camId].close(); ascWs[camId] = null; }
    ascDots[camId].className = 'ascii-status-dot';
  }

  window.asciiConnect = function() {
    connectCam(0);
    connectCam(1);
    ascFitFont();
  };

  window.asciiDisconnect = function() {
    disconnectCam(0);
    disconnectCam(1);
    ascFpsEl.textContent = '-- fps';
  };

  function ascFitFont() {
    const vp = document.getElementById('asciiViewport');
    if (!vp) return;
    const w = parseInt(document.getElementById('ascWidth').value) || 160;
    const h = parseInt(document.getElementById('ascHeight').value) || 70;
    // Each pane gets half the viewport width (minus divider + gaps)
    const maxW = (vp.clientWidth - 40) / 2;
    const maxH = vp.clientHeight - 40;
    const sizeByW = maxW / (w * 0.62);
    const sizeByH = maxH / (h * 1.15);
    const sz = Math.max(4, Math.min(16, Math.floor(Math.min(sizeByW, sizeByH)))) + 'px';
    ascOutputs[0].style.fontSize = sz;
    ascOutputs[1].style.fontSize = sz;
  }

  document.getElementById('ascCharset').addEventListener('change', ascSendAllSettings);
  document.getElementById('ascWidth').addEventListener('change', () => { ascFitFont(); ascSendAllSettings(); });
  document.getElementById('ascHeight').addEventListener('change', () => { ascFitFont(); ascSendAllSettings(); });

  document.getElementById('ascColor').addEventListener('click', function() {
    ascColorMode = !ascColorMode;
    this.classList.toggle('on', ascColorMode);
    ascSendAllSettings();
  });
  document.getElementById('ascInvert').addEventListener('click', function() {
    ascInvertMode = !ascInvertMode;
    this.classList.toggle('on', ascInvertMode);
    ascSendAllSettings();
  });
  document.getElementById('ascPause').addEventListener('click', function() {
    ascPaused = !ascPaused;
    this.classList.toggle('on', ascPaused);
    this.textContent = ascPaused ? 'RESUME' : 'PAUSE';
  });

  window.addEventListener('resize', ascFitFont);
})();
</script>
</body>
</html>
