<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>th3cl4w ‚Äî 3D Workspace Scan</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0a; color: #e0e0e0; font-family: 'JetBrains Mono', monospace; overflow: hidden; }
#canvas-container { width: 100vw; height: 100vh; position: relative; }
canvas { display: block; }
#hud {
  position: absolute; top: 12px; left: 12px;
  background: rgba(0,0,0,0.75); border: 1px solid #333; border-radius: 6px;
  padding: 10px 14px; font-size: 12px; line-height: 1.6; min-width: 200px;
  pointer-events: auto;
}
#hud h3 { color: #0f0; margin-bottom: 6px; font-size: 13px; }
#hud .stat { color: #999; }
#hud .val { color: #0f0; }
#controls {
  position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 8px;
}
#controls button {
  background: #1a1a1a; color: #0f0; border: 1px solid #333; border-radius: 4px;
  padding: 8px 16px; cursor: pointer; font-family: inherit; font-size: 12px;
}
#controls button:hover { background: #2a2a2a; border-color: #0f0; }
#controls button.active { background: #0f02; border-color: #0f0; }
#status-bar {
  position: absolute; top: 12px; right: 12px;
  background: rgba(0,0,0,0.75); border: 1px solid #333; border-radius: 6px;
  padding: 8px 12px; font-size: 11px;
}
.connected { color: #0f0; }
.disconnected { color: #f00; }
#cam-views {
  position: absolute; bottom: 60px; right: 12px;
  display: flex; flex-direction: column; gap: 4px;
}
#cam-views img {
  width: 160px; height: 120px; object-fit: cover; border: 1px solid #333;
  border-radius: 4px; opacity: 0.8;
}
#cam-views img:hover { opacity: 1; border-color: #0f0; }
</style>
</head>
<body>
<div id="canvas-container">
  <div id="hud">
    <h3>ü§ñ th3cl4w workspace</h3>
    <div><span class="stat">Points:</span> <span class="val" id="point-count">0</span></div>
    <div><span class="stat">Objects:</span> <span class="val" id="obj-count">0</span></div>
    <div><span class="stat">Voxels:</span> <span class="val" id="voxel-count">0</span></div>
    <div><span class="stat">FPS:</span> <span class="val" id="fps">0</span></div>
  </div>
  <div id="status-bar">
    <span id="ws-status" class="disconnected">‚óè disconnected</span>
  </div>
  <div id="controls">
    <button onclick="toggleArm()" id="btn-arm" class="active">Arm</button>
    <button onclick="toggleObjects()" id="btn-obj" class="active">Objects</button>
    <button onclick="toggleCloud()" id="btn-cloud" class="active">Cloud</button>
    <button onclick="toggleVoxels()" id="btn-voxel">Voxels</button>
    <button onclick="startPanorama()" id="btn-pano">üåê Panorama</button>
    <button onclick="captureSnapshot()">üì∏ Snapshot</button>
    <button onclick="clearCloud()">üóë Clear</button>
    <button onclick="resetView()">‚ü≤ Reset</button>
  </div>
  <div id="pano-progress" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.85); border:1px solid #0f0; border-radius:8px; padding:20px 30px; text-align:center; z-index:10;">
    <div style="color:#0f0; font-size:14px; margin-bottom:10px;" id="pano-label">Scanning...</div>
    <div style="width:200px; height:8px; background:#222; border-radius:4px; overflow:hidden;">
      <div id="pano-bar" style="width:0%; height:100%; background:#0f0; transition:width 0.3s;"></div>
    </div>
    <div style="color:#666; font-size:11px; margin-top:6px;" id="pano-detail">Position 0/4</div>
  </div>
  <div id="cam-views">
    <img id="cam0-img" src="" alt="cam0 (side)" title="cam0 ‚Äî side camera">
    <img id="cam1-img" src="" alt="cam1 (arm)" title="cam1 ‚Äî arm camera">
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
// --- Config ---
const MAP_SERVER = location.port === '8083' ? '' : 'http://localhost:8083';
const MAIN_SERVER = 'http://localhost:8080';
const CAM_SERVER = 'http://localhost:8081';
const WS_URL = `ws://${location.hostname}:8083/ws/map`;

// --- Three.js Setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0a);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 10);
camera.position.set(0.5, 0.6, 0.5);
camera.lookAt(0, 0.15, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.getElementById('canvas-container').prepend(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0.15, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.1;

// --- Lights ---
scene.add(new THREE.AmbientLight(0x404040, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(1, 2, 1);
scene.add(dirLight);

// --- Grid & Axes ---
const grid = new THREE.GridHelper(1.0, 20, 0x222222, 0x111111);
scene.add(grid);
const axes = new THREE.AxesHelper(0.15);
scene.add(axes);

// --- Arm skeleton group ---
const armGroup = new THREE.Group();
scene.add(armGroup);
const JOINT_COLOR = 0x00ff00;
const LINK_COLOR = 0x00cc00;
const EE_COLOR = 0xff3300;

// --- Objects group ---
const objectsGroup = new THREE.Group();
scene.add(objectsGroup);

// --- Point cloud ---
const MAX_CLOUD_POINTS = 200000;
const cloudGeometry = new THREE.BufferGeometry();
const cloudPositions = new Float32Array(MAX_CLOUD_POINTS * 3);
const cloudColors = new Float32Array(MAX_CLOUD_POINTS * 3);
cloudGeometry.setAttribute('position', new THREE.BufferAttribute(cloudPositions, 3));
cloudGeometry.setAttribute('color', new THREE.BufferAttribute(cloudColors, 3));
cloudGeometry.setDrawRange(0, 0);
const cloudMaterial = new THREE.PointsMaterial({ size: 0.004, vertexColors: true, sizeAttenuation: true });
const cloudPoints = new THREE.Points(cloudGeometry, cloudMaterial);
scene.add(cloudPoints);

// --- Voxel group ---
const voxelGroup = new THREE.Group();
voxelGroup.visible = false;
scene.add(voxelGroup);

// --- State ---
let wsConn = null;
let frameCount = 0;
let lastFpsTime = performance.now();

// --- DH params (D1 arm) ---
const DH = [
  { a: 0, d: 0.1215, alpha: -Math.PI/2 },
  { a: 0, d: 0,      alpha:  Math.PI/2 },
  { a: 0, d: 0.2085, alpha: -Math.PI/2 },
  { a: 0, d: 0,      alpha:  Math.PI/2 },
  { a: 0, d: 0.2085, alpha: -Math.PI/2 },
  { a: 0, d: 0,      alpha:  Math.PI/2 },
  { a: 0, d: 0.1130, alpha: 0 },
];

function dhMatrix(a, d, alpha, theta) {
  const ct = Math.cos(theta), st = Math.sin(theta);
  const ca = Math.cos(alpha), sa = Math.sin(alpha);
  return new THREE.Matrix4().set(
    ct, -st*ca,  st*sa, a*ct,
    st,  ct*ca, -ct*sa, a*st,
    0,   sa,     ca,    d,
    0,   0,      0,     1
  );
}

function computeFK(jointsDeg) {
  const positions = [new THREE.Vector3(0, 0, 0)];
  let T = new THREE.Matrix4().identity();
  for (let i = 0; i < Math.min(jointsDeg.length, 7); i++) {
    const theta = (jointsDeg[i] || 0) * Math.PI / 180;
    const p = DH[i] || DH[6];
    T = T.clone().multiply(dhMatrix(p.a, p.d, p.alpha, theta));
    const pos = new THREE.Vector3();
    pos.setFromMatrixPosition(T);
    positions.push(pos);
  }
  return positions;
}

function updateArm(data) {
  // Clear old
  while (armGroup.children.length) armGroup.remove(armGroup.children[0]);

  const angles = data.joint_angles_deg || data.joints || [];
  if (!angles.length) return;

  const positions = computeFK(angles);

  // Draw joints as spheres + links as cylinders
  const jointMat = new THREE.MeshPhongMaterial({ color: JOINT_COLOR, emissive: 0x003300 });
  const linkMat = new THREE.MeshPhongMaterial({ color: LINK_COLOR, transparent: true, opacity: 0.7 });

  for (let i = 0; i < positions.length; i++) {
    const isEE = i === positions.length - 1;
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(isEE ? 0.015 : 0.012, 12, 12),
      isEE ? new THREE.MeshPhongMaterial({ color: EE_COLOR, emissive: 0x330000 }) : jointMat
    );
    sphere.position.copy(positions[i]);
    armGroup.add(sphere);

    if (i > 0) {
      const start = positions[i-1], end = positions[i];
      const dir = new THREE.Vector3().subVectors(end, start);
      const len = dir.length();
      if (len > 0.001) {
        const cyl = new THREE.Mesh(
          new THREE.CylinderGeometry(0.008, 0.008, len, 8),
          linkMat
        );
        cyl.position.copy(start).add(dir.multiplyScalar(0.5));
        cyl.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());
        armGroup.add(cyl);
      }
    }
  }
}

function updateObjects(objects) {
  while (objectsGroup.children.length) objectsGroup.remove(objectsGroup.children[0]);
  document.getElementById('obj-count').textContent = objects.length;

  const colors = [0x00aaff, 0xff6600, 0xaa00ff, 0xffcc00, 0x00ffaa, 0xff0066];
  objects.forEach((obj, i) => {
    const pos = obj.position_mm || [0, 0, 0];
    const bbox = obj.bbox_mm || [50, 50, 50];
    const color = colors[i % colors.length];

    // Box mesh
    const geo = new THREE.BoxGeometry(bbox[0]/1000, bbox[1]/1000, bbox[2]/1000);
    const mat = new THREE.MeshPhongMaterial({
      color, transparent: true, opacity: 0.5,
      emissive: obj.reachable ? 0x002200 : 0x220000
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(pos[0]/1000, pos[1]/1000, pos[2]/1000);
    objectsGroup.add(mesh);

    // Wireframe
    const wire = new THREE.LineSegments(
      new THREE.EdgesGeometry(geo),
      new THREE.LineBasicMaterial({ color, linewidth: 1 })
    );
    wire.position.copy(mesh.position);
    objectsGroup.add(wire);

    // Label
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 256, 64);
    ctx.fillStyle = '#0f0'; ctx.font = '20px monospace';
    ctx.fillText(obj.label || 'unknown', 8, 40);
    const tex = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
    sprite.position.copy(mesh.position);
    sprite.position.y += bbox[1]/2000 + 0.03;
    sprite.scale.set(0.12, 0.03, 1);
    objectsGroup.add(sprite);
  });
}

function updateCloud(cloudData) {
  if (!cloudData) return;
  // cloudData can be {points: [[x,y,z,r,g,b],...]} or voxel-based
  const pts = cloudData.points || cloudData;
  if (!Array.isArray(pts)) return;

  const n = Math.min(pts.length, MAX_CLOUD_POINTS);
  const posAttr = cloudGeometry.attributes.position;
  const colAttr = cloudGeometry.attributes.color;

  for (let i = 0; i < n; i++) {
    const p = pts[i];
    posAttr.array[i*3]   = p[0];
    posAttr.array[i*3+1] = p[1];
    posAttr.array[i*3+2] = p[2];
    colAttr.array[i*3]   = (p[3] || 128) / 255;
    colAttr.array[i*3+1] = (p[4] || 128) / 255;
    colAttr.array[i*3+2] = (p[5] || 128) / 255;
  }
  posAttr.needsUpdate = true;
  colAttr.needsUpdate = true;
  cloudGeometry.setDrawRange(0, n);
  document.getElementById('point-count').textContent = n.toLocaleString();
}

function updateVoxels(voxelData) {
  while (voxelGroup.children.length) voxelGroup.remove(voxelGroup.children[0]);
  if (!voxelData || !voxelData.voxels) return;

  const voxels = voxelData.voxels;
  const size = 0.01;
  document.getElementById('voxel-count').textContent = voxels.length.toLocaleString();

  // Use instanced mesh for performance
  const geo = new THREE.BoxGeometry(size, size, size);
  const mat = new THREE.MeshPhongMaterial({ color: 0x00ff44, transparent: true, opacity: 0.3 });
  const mesh = new THREE.InstancedMesh(geo, mat, voxels.length);

  const dummy = new THREE.Object3D();
  voxels.forEach((v, i) => {
    dummy.position.set(v[0], v[1], v[2]);
    dummy.updateMatrix();
    mesh.setMatrixAt(i, dummy.matrix);
  });
  voxelGroup.add(mesh);
}

// --- WebSocket ---
function connectWS() {
  if (wsConn && wsConn.readyState <= 1) return;
  wsConn = new WebSocket(WS_URL);

  wsConn.onopen = () => {
    document.getElementById('ws-status').textContent = '‚óè connected';
    document.getElementById('ws-status').className = 'connected';
    // Subscribe to all updates
    wsConn.send(JSON.stringify({ type: 'subscribe', channels: ['arm', 'objects', 'cloud', 'voxels'] }));
  };

  wsConn.onmessage = (ev) => {
    try {
      const msg = JSON.parse(ev.data);
      if (msg.arm) updateArm(msg.arm);
      if (msg.objects) updateObjects(msg.objects);
      if (msg.cloud) updateCloud(msg.cloud);
      if (msg.voxels) updateVoxels(msg.voxels);
      // Full scene snapshot
      if (msg.type === 'scene') {
        if (msg.arm) updateArm(msg.arm);
        if (msg.objects) updateObjects(msg.objects);
      }
    } catch(e) { /* ignore parse errors */ }
  };

  wsConn.onclose = () => {
    document.getElementById('ws-status').textContent = '‚óè disconnected';
    document.getElementById('ws-status').className = 'disconnected';
    setTimeout(connectWS, 2000);
  };

  wsConn.onerror = () => wsConn.close();
}

// --- REST polling fallback ---
async function pollData() {
  try {
    const [armRes, objRes] = await Promise.all([
      fetch(`${MAP_SERVER}/api/map/arm`).then(r => r.json()).catch(() => null),
      fetch(`${MAP_SERVER}/api/map/objects`).then(r => r.json()).catch(() => null),
    ]);
    if (armRes) updateArm(armRes);
    if (objRes && objRes.objects) updateObjects(objRes.objects);
  } catch(e) { /* ok */ }
}

// --- Camera feeds ---
function updateCamFeeds() {
  document.getElementById('cam0-img').src = `${CAM_SERVER}/latest/0?t=${Date.now()}`;
  document.getElementById('cam1-img').src = `${CAM_SERVER}/latest/1?t=${Date.now()}`;
}

// --- Toggle buttons ---
function toggleArm() {
  armGroup.visible = !armGroup.visible;
  document.getElementById('btn-arm').classList.toggle('active');
}
function toggleObjects() {
  objectsGroup.visible = !objectsGroup.visible;
  document.getElementById('btn-obj').classList.toggle('active');
}
function toggleCloud() {
  cloudPoints.visible = !cloudPoints.visible;
  document.getElementById('btn-cloud').classList.toggle('active');
}
function toggleVoxels() {
  voxelGroup.visible = !voxelGroup.visible;
  document.getElementById('btn-voxel').classList.toggle('active');
  if (voxelGroup.visible) {
    fetch(`${MAP_SERVER}/api/map/voxels`).then(r => r.json()).then(updateVoxels).catch(() => {});
  }
}

async function captureSnapshot() {
  try {
    const r = await fetch(`${MAP_SERVER}/api/map/scan/start`, { method: 'POST' });
    const data = await r.json();
    alert(data.ok ? `Snapshot saved: ${data.points} points` : `Error: ${data.error}`);
  } catch(e) { alert('Snapshot failed: ' + e); }
}

async function clearCloud() {
  if (!confirm('Clear point cloud?')) return;
  await fetch(`${MAP_SERVER}/api/map/env/clear`, { method: 'POST' }).catch(() => {});
  cloudGeometry.setDrawRange(0, 0);
  document.getElementById('point-count').textContent = '0';
}

function resetView() {
  camera.position.set(0.5, 0.6, 0.5);
  controls.target.set(0, 0.15, 0);
  controls.update();
}

// --- Animation loop ---
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);

  frameCount++;
  const now = performance.now();
  if (now - lastFpsTime > 1000) {
    document.getElementById('fps').textContent = frameCount;
    frameCount = 0;
    lastFpsTime = now;
  }
}

// --- Resize ---
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// --- Panorama Scan ---
let panoPolling = null;

async function startPanorama() {
  const btn = document.getElementById('btn-pano');
  try {
    const r = await fetch(`${MAIN_SERVER}/api/scan/panorama/start`, { method: 'POST' });
    const data = await r.json();
    if (!data.ok) { alert('Panorama: ' + (data.error || 'failed')); return; }
    btn.classList.add('active');
    document.getElementById('pano-progress').style.display = 'block';
    // Poll status
    if (panoPolling) clearInterval(panoPolling);
    panoPolling = setInterval(pollPanoStatus, 1000);
  } catch(e) { alert('Panorama error: ' + e); }
}

async function pollPanoStatus() {
  try {
    const r = await fetch(`${MAIN_SERVER}/api/scan/panorama/status`);
    const s = await r.json();
    const bar = document.getElementById('pano-bar');
    const label = document.getElementById('pano-label');
    const detail = document.getElementById('pano-detail');

    const pct = (s.progress / s.total) * 100;
    bar.style.width = pct + '%';

    if (s.status === 'scanning') {
      label.textContent = 'üîÑ Scanning...';
      detail.textContent = `Position ${s.progress + 1}/4`;
    } else if (s.status === 'stitching') {
      label.textContent = 'üß© Stitching panorama...';
      detail.textContent = 'Processing images';
      bar.style.width = '90%';
    } else if (s.status === 'done') {
      label.textContent = '‚úÖ Panorama complete!';
      detail.textContent = s.timestamp || '';
      bar.style.width = '100%';
      clearInterval(panoPolling);
      panoPolling = null;
      document.getElementById('btn-pano').classList.remove('active');
      // Load as skybox after short delay
      setTimeout(() => {
        document.getElementById('pano-progress').style.display = 'none';
        loadPanoramaSkybox();
      }, 1500);
    } else if (s.status === 'error') {
      label.textContent = '‚ùå Scan failed';
      detail.textContent = s.error || 'Unknown error';
      bar.style.width = '0%';
      bar.style.background = '#f00';
      clearInterval(panoPolling);
      panoPolling = null;
      document.getElementById('btn-pano').classList.remove('active');
      setTimeout(() => {
        document.getElementById('pano-progress').style.display = 'none';
        bar.style.background = '#0f0';
      }, 3000);
    }
  } catch(e) { /* ignore */ }
}

function loadPanoramaSkybox() {
  const loader = new THREE.TextureLoader();
  loader.load(`${MAIN_SERVER}/api/scan/panorama/latest?t=${Date.now()}`, (texture) => {
    texture.mapping = THREE.EquirectangularReflectionMapping;
    // Create a large sphere with the panorama mapped inside
    const sphereGeo = new THREE.SphereGeometry(5, 64, 32);
    sphereGeo.scale(-1, 1, 1); // Invert so texture faces inward
    const sphereMat = new THREE.MeshBasicMaterial({ map: texture });
    // Remove old skybox if any
    const old = scene.getObjectByName('panorama-skybox');
    if (old) scene.remove(old);
    const skybox = new THREE.Mesh(sphereGeo, sphereMat);
    skybox.name = 'panorama-skybox';
    scene.add(skybox);
    // Also lighten background
    scene.background = null;
    action_log_msg('Panorama loaded as skybox');
  }, undefined, (err) => {
    console.warn('Failed to load panorama skybox:', err);
  });
}

function action_log_msg(msg) { console.log('[th3cl4w]', msg); }

// Try loading latest panorama on startup
setTimeout(() => {
  fetch(`${MAIN_SERVER}/api/scan/panorama/status`).then(r => r.json()).then(s => {
    if (s.status === 'done') loadPanoramaSkybox();
  }).catch(() => {});
}, 2000);

// --- Init ---
connectWS();
setInterval(pollData, 3000);  // fallback polling
setInterval(updateCamFeeds, 2000);  // camera thumbnails
animate();
</script>
</body>
</html>
